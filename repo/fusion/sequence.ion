// Copyright (c) 2012-2013 Amazon.com, Inc.  All rights reserved.

(module sequence '/fusion/base'

  '''
Ordered collections of values.

A _sequence_ is an ordered [collection](fusion/collection.html) of values,
keyed by non-negative integers.

The built-in sequence types are [list](fusion/list.html) and
[sexp](fusion/sexp.html).

Currently, some of these features may be restricted to a subset of sequence
types.
  '''

  (require
    "/fusion/collection"
    "/fusion/experimental/defines"
    "/fusion/private/builtins"   // Some basic list ops
    "/fusion/unsafe/list")

  // Pass-through bindings from /fusion/collection
  (provide any do find is_empty size)


  (defpub_j add    "com.amazon.fusion.AddProc")

  (defpub first
    (lambda (sequence)
      '''
Returns the first element in the `sequence`. Fails if the sequence has no
elements.
      '''
      (if (= 0 (size sequence))
        (raise_argument_error "first" "non-empty sequence" 0 sequence)
        (. sequence 0))))


  (defpub last
    (lambda (sequence)
      '''
Returns the last element in the `sequence`. Fails if the sequence has no
elements.
      '''
      (let [(s (size sequence))]
        (if (= 0 s)
          (raise_argument_error "last" "non-empty sequence" 0 sequence)
          (. sequence (- s 1))))))


  //==========================================================================
  // Mapping, searching, etc.

  // Name per Dylan.  I prefer `choose` over `filter` because the latter is
  // ambiguous whether you're filtering "in" or "out".
  (defpub choose
    (lambda (pred list)
      '''
Applies the one-parameter predicate `pred` to each element of `list`, returning
a new list of the elements (in order) for which `pred` returns truthy.
      '''
      (if (not (is_list list))
        (raise_argument_error "choose" "list" 1 pred list)
        (let [(len (size list))]
          (let loop [(i 0),
                     (result (stretchy_list))]
            (if (= i len)
              result
              (let [(elt (. list i))]
                (loop
                  (+ 1 i)
                  (if (pred elt)
                    (unsafe_list_add_m result elt)
                    result)))))))))


  // Name per Dylan and SRFI-1. Dylan allows mapping over multiple key-value
  // collections but that's a bit crazy and it's unclear how useful that is.
  (defpub map
    (lambda (proc list)
      '''
Applies the one-parameter procedure `proc` to each element of `list`, returning
a new list of the results in order.
      '''
      (if (not (is_list list))
        (raise_argument_error "map" "list" 1 proc list)
        (let [(len (size list))]
          (let loop [(i 0),
                     (result (stretchy_list))]
            (if (= i len)
              result
              (loop
                (+ 1 i)
                (unsafe_list_add_m result (proc (. list i))))))))))
)
