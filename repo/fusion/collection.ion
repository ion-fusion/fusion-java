// Copyright (c) 2012-2013 Amazon.com, Inc.  All rights reserved.

(module collection '/fusion/private/builtins'

  '''
Generic operations over collection types.

The built-in collection types are [list](fusion/list.html),
[sexp](fusion/sexp.html), and [struct](fusion/struct.html).

See also [sequence](fusion/sequence.html).
  '''

  (require
    "/fusion/experimental/defines"
    "/fusion/number"
    "/fusion/private/bind"
    "/fusion/private/compare"
    "/fusion/private/control"
    "/fusion/private/sexp"
    "/fusion/unsafe/list"
    "/fusion/unsafe/sexp"
    "/fusion/unsafe/struct"
    "/fusion/void")


  (provide size)


  (defpub element
    (lambda (collection key)
      '''
Returns an element within a collection.  The `collection` must be a non-null,
non-empty list, sexp, or struct.  The `key` must have a type appropriate for
the collection: an int for lists or sexps, a string or symbol for structs.

    (element [0, 1] 0)       =>  0
    (element (sexp 0 1) 1)   =>  1
    (element {f:2} "f")      =>  2

Since `element` is a procedure, field names must be quoted or else they will
be evaluated as a variable reference:

    (element {f:2} f)        => ERROR: Unbound variable reference
    (let [(g "f")]
      (element {f:2} g))     => 2

An exception is raised if the `collection` has an unsupported type, if the
`key` isn't appropriate for the collection, or if the `key` doesn't identify
an element within the collection.

    (element [0, 1] 2)       =>  ERROR
    (element [0, 1] "2")     =>  ERROR
    (element {f:2} "g")      =>  ERROR
      '''
      (cond
        ((is_list collection)
         (if (is_int key)
           (if (and key  // null check
                    (<= 0 key)
                    (< key (unsafe_list_size collection)))
             (unsafe_list_ref collection key)
             (raise_argument_error "element" "valid position" 1 collection key))
           (raise_argument_error "element" "int" 1 collection key)))
        //-
        ((is_struct collection)
         (if (and (or (is_string key) (is_symbol key))
                  key)  // null check
           (unsafe_struct_ref collection key
             (lambda ()
               (raise_argument_error "element" "valid field name"
                 1 collection key)))
           (raise_argument_error "element" "non-null string or symbol"
             1 collection key)))
        ((is_sexp collection)
         (if (is_int key)
           (if (and key  // null check
                    (<= 0 key))
             (let loop [(key key), (s collection)]
               (if (is_pair s)
                 (if (= 0 key)
                   (unsafe_pair_head s)
                   (loop (- key 1) (unsafe_pair_tail s)))
                 (raise_argument_error "element" "valid position"
                   1 collection key)))
             (raise_argument_error "element" "valid position" 1 collection key))
           (raise_argument_error "element" "int" 1 collection key)))
        (true
         (raise_argument_error "element" "collection" 0 collection key)))))


  (defpub elt
    (lambda (collection key)
      '''
Returns an element within a collection, being lenient.  The `collection` must
be a list, sexp, struct, or void.  The `key` must have a type appropriate for
the collection: an int for lists or sexps, a string or symbol for structs.

    (elt [0, 1] 0)       =>  0
    (elt (sexp 0 1) 1)   =>  1
    (elt {f:2} "f")      =>  2

If the `collection` is empty, null, or void, the result is void.  If the `key`
isn't appropriate for the collection, or if the `key` doesn't identify an
element within the collection, the result is void.

    (elt null.list 0)    =>  void
    (elt [0, 1] 2)       =>  void
    (elt [0, 1] "2")     =>  void
    (elt {f:2} "g")      =>  void

Since `elt` is a procedure, field names must be quoted or else they will
be evaluated as a variable reference:

    (elt {f:2} f)        => ERROR: Unbound variable reference
    (let [(g "f")]
      (elt {f:2} g))     => 2

An exception is raised if the `collection` has an unsupported type.
      '''
      (cond
        ((is_list collection)
         (when (and (is_int key)
                    key  // null check
                    (<= 0 key)
                    (< key (unsafe_list_size collection)))
           (unsafe_list_ref collection key)))
        //-
        ((is_struct collection)
         (when (and (or (is_string key) (is_symbol key))
                    key)  // null check
           (unsafe_struct_ref collection key void)))
        //-
        ((is_sexp collection)
         (when (and (is_int key)
                    key  // null check
                    (<= 0 key))
           (let loop [(key key), (s collection)]
             (if (is_pair s)
               (if (= 0 key)
                 (unsafe_pair_head s)
                 (loop (- key 1) (unsafe_pair_tail s)))
               (void)))))
        //-
        ((is_void collection)
         (void))
        (true
         (raise_argument_error "elt" "collection or void" 0 collection key)))))


  (defpub .
    '''
    (. value key ...)

Traverses a "path" through a data structure, folding the `value` through each
`key` in turn.  When the value is void, it is returned immediately and any
further keys are not applied.  If a `key` is a procedure, it must accept one
argument; the procedure is applied to the current value, and the result becomes
the value for the next key.  Otherwise, the `key` and value are passed to `elt`
to get the next value.

    (. [0, 1] 0)       =>  0
    (. (sexp 0 1) 1)   =>  1
    (. {f:2} "f")      =>  2

    (. [0, 1, 2, 3] size)               =>  4
    (. (sexp 0 1 2 3) head)             =>  0
    (. (sexp 0 1 2 3) tail)             =>  (1 2 3)
    (. (sexp 0 1 2 3) tail tail head)   =>  2

Since `.` is a procedure, field names must be quoted or else they will
be evaluated as a variable reference:

    (. {f:2} f)        => ERROR: Unbound variable reference
    (let [(g "f")]
      (. {f:2} g))     => 2
    '''
    (lambda rest
      (let [(size (size rest))]
        (if (= size 0)
          (apply raise_arity_error "." 1 rest)
          (let loop [(pos 1),
                     (val (elt rest 0))]
            (if (or (= pos size) (is_void val))
              val
              (let [(key (elt rest pos))]
                (loop (+ 1 pos)
                  (if (is_procedure key)
                    (key val)
                    (elt val key))))))))))


  //==========================================================================


  // Name per Dylan and SRFI-1.
  (defpub any
    (lambda (pred collection)
      '''
Applies the one-parameter predicate `pred` to the elements of `collection`;
the first time `pred` returns a truthy value that truthy value is returned and
no more elements are visited.  If no call returns a truthy value, then the
result is `false`.

When `collection` is a sequence, the elements are visited in order.
      '''
      (cond
        ((is_struct collection)
         (let [(result false)]
           // WARNING!  This unsafe procedure is UNSUPPORTED!
           (unsafe_struct_visit (lambda (key elt)
                                  (let [(elt_result (pred elt))]
                                    (when elt_result (set result elt_result))
                                    elt_result))
             collection)
           result))
        (true    // TODO FUSION-141 optimize for list vs sexp
         (let [(len (size collection))]
           (let loop [(i 0)]
             (if (= i len)
               false
               (lets [(elt (element collection i)),
                      (result (pred elt))]
                 (if result result
                   (loop (+ i 1)))))))))))


  (defpub is_empty
    (lambda (collection)
      '''
Returns `true` if the size of the `collection` is zero, otherwise returns
`false`.
      '''
      (= 0 (size collection))))


  // Name per SRFI-1
  (defpub find
    (lambda (pred collection)
      '''
Applies the one-parameter predicate `pred` to each element of `collection`;
the first time `pred` returns a truthy value that element is returned.
If no such element is found, the result is void.

When `collection` is a sequence, the elements are visited in order.
      '''
      (cond
        ((is_struct collection)
         (let [(result (void))]
           // WARNING!  This unsafe procedure is UNSUPPORTED!
           (unsafe_struct_visit (lambda (key elt)
                                  (let [(elt_result (pred elt))]
                                    (when elt_result (set result elt))
                                    elt_result))
             collection)
           result))
        (true    // TODO FUSION-141 optimize for list vs sexp
         (let [(len (size collection))]
           (let loop [(i 0)]
             (if (= i len)
               (void)
               (let [(elt (element collection i))]
                 (if (pred elt)
                   elt
                   (loop (+ i 1)))))))))))


  // Name per Dylan.  Equivalent to SRFI-1 `for_each` but I don't want this to
  // be confused with the `for` syntax from Racket (which I intend to provide).
  (defpub do
    (lambda (proc collection)
      '''
Applies the one-parameter procedure `proc` to the elements of `collection`,
ignoring any results.  Returns void.

When `collection` is a sequence, the elements are visited in order.
      '''
      // We return void (rather than the collection) because this should
      // eventually accept multiple collections to walk in parallel, and then
      // it doesn't make sense to return the first one.
      (cond
        ((is_struct collection)
         // WARNING!  This unsafe procedure is UNSUPPORTED!
         (unsafe_struct_visit
           (lambda (key elt) (proc elt) false)
           collection)
         (void))
        (true    // TODO FUSION-141 optimize for list vs sexp
         (let [(len (size collection))]
           (let loop [(i 0)]
             (if (= i len)
               (void)
               (begin
                 (proc (element collection i))
                 (loop (+ 1 i))))))))))

)
