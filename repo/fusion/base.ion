// Copyright (c) 2012-2013 Amazon.com, Inc.  All rights reserved.

(module base '/fusion/private/builtins'

  (require
    "/fusion/experimental/defines"
    "/fusion/syntax")


  // Pass-through bindings from kernel
  // TODO FUSION-133 remove `use`
  (provide all_defined_out begin define if lambda letrec module provide
    require use)
  (provide is_bool is_int is_float is_decimal is_timestamp is_symbol
      is_string is_clob is_blob is_list is_sexp is_struct)
  // Note that there's no is_null type checker, since that's used to
  // check for *any* null value.


  // Pass-through bindings from builtins
  (provide assert for_list let let_values quote set '#%top')
  (provide . apply concatenate exit is_null is_procedure not
    raise_argument_error raise_result_error
    to_int to_string)

  // TODO FUSION-107 remove concatenate above

  // TODO FUSION-95 these bindings seem out of place:
  //  assert for_list concatenate to_int to_string raise_*

  (require "/fusion/private/compare")
  (provide < <= = >= >)

  (require "/fusion/number")
  (provide + - * /)

  (require "/fusion/void")
  (provide is_void void)


  //==========================================================================
  // Binding forms

/*
(lets [] body ...+)
=>
(begin body ...)

(lets [binding, others ...] body ...+)
=>
(let [binding]
  (lets [others ...]
    body ...))
*/

  (defpub_syntax lets
    '''
    (lets [(ident expr), ...] body ...+)

Like `let`, but each binding is created (and its `expr` evaluated) one by one,
and the `ident`s are bound in the following `expr`s as well as the `body`.

    (lets [(a 1),
           (b (+ a 1))]
      [a, b])            => [1, 2]
    '''
    (lambda (stx)
      (if (< (syntax_size stx) 3)
        (wrong_syntax stx "expecting bindings and body")
        (let [(bindings (syntax_get    stx 1)),
              (body     (syntax_subseq stx 2))]
          // TODO FUSION-120 check type of bindings, bound identifier
          (if (= 0 (syntax_size bindings))
              (syntax_cons_q begin body)
              (let [(binding (syntax_get    bindings 0)),
                    (others  (syntax_subseq bindings 1))]
                (quasisyntax
                  (let ((unsyntax binding))   // TODO FUSION-46 can't use [] here
                    (unsyntax
                      (syntax_append
                        (quasisyntax (lets (unsyntax others)))
                        body))))))))))


  //==========================================================================
  // Control forms

  (defpub_syntax and  // WARNING: Doc syntax isn't supported yet.
    '''
    (and expr ...)

Evaluates the EXPRs from left to right, returning the first untruthy value
that results (and ignoring further expressions). If they all return truthy
values, the last one is returned.

The last EXPR is in tail position. Given no EXPRs, the result is true.
    '''
    (lambda (stx)
      // (and)          -->  true
      // (and A)        -->  A
      // (and A B ...)  -->  (let [(a A)] (if a (and B ...) a))

      (let [(size (syntax_size stx))]
        (if (= 1 size)
          (quote_syntax true)
          (if (= 2 size)
            (syntax_get stx 1)
            (let [(first (syntax_get    stx 1)),
                  (rest  (syntax_subseq stx 2))]
              (let [(inner (syntax_cons_q and rest))]
                (quasisyntax
                  (let ((a (unsyntax first)))
                    (if a (unsyntax inner) a))))))))))


  (defpub_syntax or  // WARNING: Doc syntax isn't supported yet.
    '''
    (or expr ...)

Evaluates the EXPRs from left to right, returning the first truthy value
that results (and ignoring further expressions). If they all return untruthy
values, the last one is returned.

The last EXPR is in tail position. Given no EXPRs, the result is false.
    '''
    (lambda (stx)

      // (or)          -->  false
      // (or A)        -->  A
      // (or A B ...)  -->  (let [(a A)] (if a a (and B ...)))

      (let [(size (syntax_size stx))]
        (if (= 1 size)
          (quote_syntax false)
          (if (= 2 size)
            (syntax_get stx 1)
            (let [(first (syntax_get    stx 1)),
                  (rest  (syntax_subseq stx 2))]
              (let [(inner (syntax_cons_q or rest))]
                (quasisyntax
                  (let ((a (unsyntax first)))
                    (if a a (unsyntax inner)))))))))))


  (defpub_syntax when  // WARNING: Doc syntax isn't supported yet.
    '''
    (when test body ...)

Evaluates the TEST, and if it is truthy, evaluates the BODY expressions left
to right. The last BODY is in tail position, and its result is the result of
the entire form.  If the body isn't evaluated, the result is void.
    '''
    (lambda (stx)

      // (when TEST BODY ...)  -->  (if TEST (begin BODY ...) (void))

      (if (= 1 (syntax_size stx))
        (wrong_syntax stx "expected condition")
        (let ((test (syntax_get    stx 1))
              (body (syntax_subseq stx 2)))
          (let ((begin_body (syntax_cons_q begin body)))
            (quasisyntax
              (if (unsyntax test)
                  (unsyntax begin_body)
                  (void))))))))

  (defpub_syntax unless  // WARNING: Doc syntax isn't supported yet.
    '''
    (unless test body ...)

Evaluates the TEST, and if it is _not_ truthy, evaluates the BODY expressions
left to right. The last BODY is in tail position, and its result is the result
of the entire form.  If the body isn't evaluated, the result is void.
    '''
    (lambda (stx)

      // (unless TEST BODY ...)  -->  (if TEST (void) (begin BODY ...))

      (if (= 1 (syntax_size stx))
        (wrong_syntax stx "expected condition")
        (let ((test (syntax_get    stx 1))
              (body (syntax_subseq stx 2)))
          (let ((begin_body (syntax_cons_q begin body)))
            (quasisyntax
              (if (unsyntax test)
                  (void)
                  (unsyntax begin_body))))))))


// TODO FUSION-36  Support internal definitions in body sequences.
// Shouldn't use begin since that doesn't delimit the new scope that's needed.

  (defpub_syntax cond  // WARNING: Doc syntax isn't supported yet.
    '''
    (cond (test body ...) ...)

Evaluates the TEST expressions left to right until one returns a truthy value,
then evaluates the corresponding BODY in tail position.
If no TEST is truthy, the result is void.
    '''
    (lambda (stx)
      (let ((size (syntax_size stx)))
        (if (= 1 size)               // (cond) with no clauses
          (quote_syntax (void))
          (let ((clause (syntax_get    stx 1))
                (tail   (syntax_subseq stx 2)))
            // TODO FUSION-120 check type of clause
            (when (> 1 (syntax_size clause))
              (wrong_syntax stx "cond: bad clause " clause))
            (let ((test (syntax_get    clause 0))
                  (body (syntax_subseq clause 1)))
              (let ((begin_body (syntax_cons_q begin body))
                    (cond_tail  (syntax_cons_q cond  tail)))
                (quasisyntax
                  (if (unsyntax test)
                      (unsyntax begin_body)
                      (unsyntax cond_tail))))))))))

)
