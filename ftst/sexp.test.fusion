// Copyright (c) 2012-2014 Amazon.com, Inc.  All rights reserved.

(require
  "/check"
  "/fusion/list"
  "/fusion/private/builtins"  // annotate
  "/fusion/private/sexp")


(define valNull  (quote null.sexp))
(define valEmpty (quote ()))
(define val12    (quote (1 2)))


(define _sexp_copy
  (lambda (ctor v)
    (apply annotate
      (if (is_null v)
        v
        (apply ctor v))
      (type_annotations v))))

(define sexp_copy
  (lambda (v)
    (_sexp_copy sexp v)))

(define mutable_list_copy
  (lambda (v)
    (_sexp_copy mutable_sexp v)))


(define_check (check_mod_f msg op val args expect)
  "Functional modification check"
  (let [(v (sexp_copy val))]
    (let [(result (apply op v args))]
      (check === result expect
        "Unexpected result from " op " on immutable arg")
      (check === v val                                        // v not mutated
        "Immutable arg was mutated by " op))))


//==========================================================================
// Literals

//(check_true (is_null  null.sexp))  // Not valid syntax
//(check_true (is_empty null.sexp))
(check_true (is_null  (quote null.sexp)))
(check_true (is_empty (quote null.sexp)))
(check_true (is_null  (quote a::null.sexp)))
(check_true (is_empty (quote a::null.sexp)))

(check_false (is_null (quote ())))
(check_false (is_null (quote a::())))


(define test_predicates
  (lambda (sexp empty)
    (check_pred is_collection sexp)
    (check_pred is_sequence sexp)
    (check_pred is_sexp sexp)
    (check = (is_empty sexp) empty)
    // TODO ...
    ))


// Construction via literals

(define x "anything")

(test_predicates (quote ())    true)
(test_predicates (quote (0))   false)
(test_predicates (quote (0 T)) false)


// Construction via procedures

(define test_makers
  (lambda (maker)
    (test_predicates (apply maker (quote ())) true)
    (test_predicates (apply maker (quote (0))) false)
    (check === (apply maker (quote ())) EMPTY_SEXP)
    (check === (apply maker (quote (0 1)))
      (quote (0 1)))))

(test_makers sexp)
// TODO immutable_sexp


(check_annotations (quote ()) (quote []))
(check_annotations (quote a::(c)) (quote ["a"]))
(check_annotations (quote a::b::(c d)) (quote ["a","b"]))
(check_annotations (quote a::b::a::(a)) (quote ["a","b","a"]))


//==========================================================================
// pair


// TODO FUSION-268 is_sexp/is_collection accept any pair, not just proper sexp
// Need to analyze that before releasing this!
(lets [(h (list 1)),
       (t (list 2)),
       (p (pair h t))]
  (check_pred is_collection p)
  (check_pred is_sequence p)
  (check_pred is_sexp p)
  (check ident (head p) h)
  (check ident (tail p) t)
  (check === p (pair [1] [2])))


//==========================================================================
// annotate

(check_mod_f annotate NULL_SEXP []         (quote       null.sexp))
(check_mod_f annotate NULL_SEXP ["a"]      (quote a::   null.sexp))
(check_mod_f annotate NULL_SEXP ["a", "b"] (quote a::b::null.sexp))

(check_mod_f annotate valEmpty []         (quote       ()))
(check_mod_f annotate valEmpty ["a"]      (quote a::   ()))
(check_mod_f annotate valEmpty ["a", "b"] (quote a::b::()))

(check_mod_f annotate val12 []         (quote       (1 2)))
(check_mod_f annotate val12 ["a"]      (quote a::   (1 2)))
(check_mod_f annotate val12 ["a", "b"] (quote a::b::(1 2)))


// Replacing existing annotations
(check_mod_f annotate (quote x::null.sexp) ["a"]      (quote a::   null.sexp))
(check_mod_f annotate (quote x::null.sexp) ["a", "b"] (quote a::b::null.sexp))

(check_mod_f annotate (quote x::()) []         (quote       ()))
(check_mod_f annotate (quote x::()) ["a"]      (quote a::   ()))
(check_mod_f annotate (quote x::()) ["a", "b"] (quote a::b::()))

(check_mod_f annotate (quote x::(1)) []         (quote       (1)))
(check_mod_f annotate (quote x::(1)) ["a"]      (quote a::   (1)))
(check_mod_f annotate (quote x::(1)) ["a", "b"] (quote a::b::(1)))


(check_arg_exn (annotate NULL_SEXP null))
(check_arg_exn (annotate NULL_SEXP ""))
(check_arg_exn (annotate NULL_SEXP null.string))
(check_arg_exn (annotate NULL_SEXP (quote null.symbol)))
(check_arg_exn (annotate NULL_SEXP 12))


//==========================================================================
// has_key

(check_false (has_key valNull ""))
(check_false (has_key valNull null.int))
(check_false (has_key valNull -1))
(check_false (has_key valNull 0))
(check_false (has_key valNull 1))

(check_false (has_key valEmpty ""))
(check_false (has_key valEmpty null.int))
(check_false (has_key valEmpty -1))
(check_false (has_key valEmpty 0))
(check_false (has_key valEmpty 1))

(check_false (has_key val12 null.string))
(check_false (has_key val12 -1))
(check_false (has_key val12 3))

(check_true (has_key val12 0))
(check_true (has_key val12 1))

(check_true (has_key (sexp null)   0))
(check_true (has_key (sexp false)  0))
(check_true (has_key (sexp (void)) 0))

(check_arity_exn (has_key))
(check_arity_exn (has_key []))


//==========================================================================
// first

(check = (first (quote (1))) 1)
(check = (first (sexp 1 2)) 1)

(check_arg_exn (first (quote null.sexp)))
(check_arg_exn (first (sexp)))


//==========================================================================
// last

(check = (last (quote (1))) 1)
(check = (last (sexp 1 2)) 2)

(check_arg_exn (last (quote null.sexp)))
(check_arg_exn (last (sexp)))


//==========================================================================
// add

(check === (add (sexp 1 2) 3)  (sexp 3 1 2))
(check === (add (sexp 1 2) [3])  (sexp [3] 1 2))


//==========================================================================
// find

(assert (is_void (find F valNull)))
(assert (is_void (find F valEmpty)))
(assert (is_void (find F val12)))
(check = (find T val12) 1)
(check = (find (lambda (e) (= e 2)) val12) 2)


//==========================================================================
// any

(check_false (any T valNull))
(check_false (any T valEmpty))
(check_false (any F val12))
(check_true  (any T val12))

(check_true  (any (lambda (e) (= e "hi")) (sexp "oh" "hi")))
(check_false (any (lambda (e) (= e "ho")) (sexp "oh" "hi")))

// Check that it returns the truthy predicate result, not the selected element
(check === 408
  (any (lambda (e) (when (= e 204) (* e 2)))
    (sexp 123 204 567)))
(check === 1134
  (any (lambda (e) (when (= e 567) (* e 2)))
    (sexp 123 204 567)))

// Check than it returns the last predicate result if none are truthy
(check_pred (conjoin is_null is_int)
  (any (lambda (s) (if (is_void s) null.int null))
    (sexp false (void))))
(check_pred (conjoin is_null is_int)
  (any (lambda (s) (if (is_null s) null.int null))
    (sexp false null.int)))
(check_void
  (any (lambda (s) (if (is_null s) (void) null))
    (sexp false null.int null.list)))


//==========================================================================
// every

(check_true (every T valNull))
(check_true (every T valEmpty))
(check_false (every F val12))
(check_true  (every T val12))

(check_false (every (lambda (e) (= e "hi")) (sexp "oh" "hi")))
(check_true  (every (lambda (e) (= e "hi")) (sexp "hi" "hi")))

// Check that it returns the untruthy predicate result
(check_void
  (every (lambda (e) (when (= e 204) e))
    (sexp 123 204 567)))
(check_pred is_null
  (every (lambda (e) (if (= e 123) e null))
    (sexp 123 456 678)))

// Check that `every` returns the last predicate result if all are truthy
(check === 1134
  (every (lambda (e) (when (or (= e 123) (= e 567)) (* e 2)))
    (sexp 123 123 567)))


//==========================================================================
// map

(check === (map + NULL_SEXP) EMPTY_SEXP)
(check === (map + EMPTY_SEXP) EMPTY_SEXP)
(check === (map + (sexp 1 2)) (sexp 1 2))
(check === (map (lambda (n) (+ 3 n)) (sexp 1 2)) (sexp 4 5))

(check === (choose T EMPTY_SEXP) EMPTY_SEXP)
(check === (choose F EMPTY_SEXP) EMPTY_SEXP)
(check === (choose T NULL_SEXP)  EMPTY_SEXP)
(check === (choose F NULL_SEXP)  EMPTY_SEXP)
(check === (choose T (sexp 1 2)) (sexp 1 2))
(check === (choose F (sexp 1 2)) EMPTY_SEXP)

(check === (choose (lambda (n) (< 10 n)) (sexp 1 11 10 12)) (sexp 11 12))


//==========================================================================
// do

(check_void (do (lambda (x) (+ 1 x)) (quote (2 3))))

(let [(v (stretchy_list))]
  (do (lambda (x) (add_m v (+ 1 x))) (quote (2 3)))
  (check === v [3, 4] "do side effects"))


//==========================================================================
// size

(check === (size (quote ())) 0)
(check === (size (sexp 1)) 1)
(check === (size (sexp 1 51)) 2)
(check === (size (pair 1 (pair 2 (quote ())))) 2)

(check_arg_exn (size (pair 1 215)))


//==========================================================================
// sexp_append

(check === EMPTY_SEXP
  (sexp_append EMPTY_SEXP EMPTY_SEXP))
(check === EMPTY_SEXP
  (sexp_append EMPTY_SEXP NULL_SEXP))
(check === EMPTY_SEXP
  (sexp_append NULL_SEXP EMPTY_SEXP))
(check === EMPTY_SEXP
  (sexp_append NULL_SEXP NULL_SEXP))

(check === (sexp 1)
  (sexp_append (sexp 1) EMPTY_SEXP))
(check === (sexp 1)
  (sexp_append (sexp 1) NULL_SEXP))

(check === (sexp 1 2 3)
  (sexp_append (sexp 1 2 3) EMPTY_SEXP))
(check === (sexp 1 2 3)
  (sexp_append (sexp 1 2 3) NULL_SEXP))

(let [(s123 (sexp 1 2 3))]
  (check ident s123
    (sexp_append EMPTY_SEXP s123))
  (check ident s123
    (sexp_append NULL_SEXP s123))
  (let [(r (sexp_append (sexp 4 5 6) s123))]
    (check === (sexp 4 5 6 1 2 3) r)
    (check ident s123 (tail (tail (tail r))))))

(check === (sexp 1 2)
  (sexp_append (sexp 1) (sexp 2)))


// TODO test annotations

