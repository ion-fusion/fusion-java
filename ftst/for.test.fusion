// Copyright (c) 2012-2014 Amazon.com, Inc.  All rights reserved.

(require
  "/fusion/experimental/check"
  "/fusion/for")


(check === [73]
  (for_list () 73))

(check === [84]
  (fors_list [] 84))

(check === []
  (for_list ((e [])) 73))

(check === []
  (fors_list ((e [])) 84))

(check === [73]
  (for_list ((e [1])) 73))

(check === [84]
  (fors_list ((e [2])) 84))

(check === [1]
  (for_list ((e [1])) e))

(check === [2]
  (fors_list ((e [2])) e))

(check === [11, 22, 33]
  (for_list ((e [1, 2, 3])
             (f [10, 20, 30]))
    (+ e f)))

(check === [11, 21, 31, 12, 22, 32, 13, 23, 33]
  (fors_list ((e [1, 2, 3])
              (f [10, 20, 30]))
    (+ e f)))

(check === [11, 22]
  (for_list ((e [1, 2, 3])
             (f [10, 20]))
    (+ e f)))

(check === [11, 21, 12, 22, 13, 23]
  (fors_list ((e [1, 2, 3])
              (f [10, 20]))
    (+ e f)))

// Sexp works too
(check === [11, 22]
  (for_list ((e (quote (1 2)))
             (f [10, 20, 30]))
    (+ e f)))

(check === [11, 21, 31, 12, 22, 32]
  (fors_list ((e (quote (1 2)))
              (f [10, 20, 30]))
    (+ e f)))

// Macro in bound-value position
(check === [74]
  (for_list ((e (let ((list [1])) list))) (+ e 73)))

(check === [85]
  (fors_list ((e (let ((list [1])) list))) (+ e 84)))

// Macro in body position
(check === [74]
  (for_list ((e [1])) (let ((v 73)) (+ e v))))

(check === [85]
  (fors_list ((e [1])) (let ((v 84)) (+ e v))))

// This tests two things:
//  1) non-Ion types in the result; here, closures.
//  2) use of new locations for the bound variables each iteration.
//     The thunks are applied after iteration completes, each one should have
//     its own location for variable `e`.
(check === [2, 4, 6]
  (map (lambda (thunk) (thunk))
    (for_list ((e [1, 2, 3]))
      (lambda () (* 2 e)))))

(check === [3, 6, 9]
  (map (lambda (thunk) (thunk))
    (fors_list ((e [1, 2, 3]))
      (lambda () (* 3 e)))))

// Check access to variables in surrounding scopes.
(lets [(data         [{ amountPosted:{ amount:-39.99 }},
                      { amountPosted:{ amount:-49.99 }} ]),
       (amountPosted "amountPosted"),
       (amount       "amount")]
  (check === [-39.99, -49.99]
    (for_list [(x data)]
      (. x  amountPosted   amount))))

(lets [(data         [{ amountsPosted:[ { amount:-39.99 }, { amount:-29.99 } ]},
                      { amountsPosted:[ { amount:-49.99 }, { amount:-59.99 } ]} ]),
       (amountsPosted "amountsPosted"),
       (amount        "amount")]
  (check === [-39.99, -29.99, -49.99, -59.99]
    (fors_list [(x data),
                (y (. x amountsPosted))]
      (. y amount))))

(expect_syntax_exn (for_list))
(expect_syntax_exn (fors_list))
(expect_syntax_exn (for_list 1 2))
(expect_syntax_exn (fors_list 1 2 ))
(expect_syntax_exn (for_list null.sexp 13))
(expect_syntax_exn (fors_list null.sexp 24))
(expect_syntax_exn (for_list (12) 13))
(expect_syntax_exn (fors_list (23) 24))
(expect_syntax_exn (for_list (1 2) 13))
(expect_syntax_exn (fors_list (2 3) 24))
(expect_syntax_exn (for_list (()) 13))
(expect_syntax_exn (fors_list (()) 24))
(expect_syntax_exn (for_list ((12)) 13))
(expect_syntax_exn (fors_list ((23)) 24))
(expect_syntax_exn (for_list ((name)) 13))
(expect_syntax_exn (fors_list ((name)) 24))
(expect_syntax_exn (for_list ((name 1 2)) 13))
(expect_syntax_exn (fors_list ((name 2 3)) 24))
(expect_syntax_exn (for_list ((name 1) ()) 13))
(expect_syntax_exn (fors_list ((name 2) ()) 24))
(expect_syntax_exn (for_list ((name 1) (name2)) 13))
(expect_syntax_exn (fors_list ((name 2) (name3)) 24))
(expect_syntax_exn (for_list  ((name 1)) /* no body */))
(expect_syntax_exn (fors_list ((name 1)) /* no body */))

// Duplicate name
(expect_syntax_exn (for_list [(name []), (name [])] 13))

// Duplicate fors_list binding names are allowed because they shadow
// each other in order, the last of which is still meaningful.
(check === []
  (fors_list [(name []), (name [])] 14))
(check === [3,4,3,4]
  (fors_list [(name [1,2]), (name [3,4])] name))

"PASSED" // Helpful output if you run this stand-alone
