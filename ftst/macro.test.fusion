// Copyright (c) 2012-2014 Amazon.com, Inc.  All rights reserved.

(require
  "/check"
  "/fusion/experimental/syntax")


// Very basic macro
(define_syntax S1
  (lambda (stx) (quote_syntax 99)))

(check === (S1) 99)


// Test use of macro as body of define_syntax
(define_syntax S2
  (let ((xform (lambda (stx) (quote_syntax 99))))
    xform))

(check === (S2) 99)


// (D v i) => (define i (lambda () v))
(define_syntax D
  (lambda (stx)
    (quasisyntax
      (define (unsyntax (syntax_get stx 2))
        (lambda () (unsyntax (syntax_get stx 1)))))))

(D 67 x)
(check === (x) 67)


// Macro inside of unsyntax
(define_syntax D2
  (lambda (stx)
    (quasisyntax
      ( + 2 (unsyntax (let ((x (quote_syntax 220)))
                        (quasisyntax (unsyntax x))))))))
(check === (D2) 222)


// Macro with tail call
(define s3
  (lambda () (quote_syntax 99)))
(define_syntax S3
  (lambda (stx) (apply s3 [])))
(check === (S3) 99)


//============================================================================
// identifier bindings

(define_syntax fie
  (lambda (stx)
    (let ((id1 (syntax_get stx 1))
          (id2 (syntax_get stx 2)))
      (if (free_identifier_equal id1 id2)
        (quote_syntax true)
        (quote_syntax false)))))
(check === (fie < <) true )
(check === (fie < >) false)
(check === (fie unbound unbound) true)

// Generate two identifiers with the same name but different marks.
// They are not free_identifier_equal because of those marks.
(define_syntax make_id
  (lambda (stx)
    (quote_syntax
      (let ((id "dummy"))       // Each use of make_id makes a fresh id
        (quote_syntax id)))))
(define_syntax compare_diff_ids
  (lambda (stx)
    (let ((id1 (make_id))
          (id2 (make_id)))
      (quasisyntax (fie (unsyntax id1) (unsyntax id2))))))
(check === (compare_diff_ids) false)


//============================================================================
// syntax_append

(define_syntax join
  (lambda (stx)
    (syntax_append (syntax_get stx 1) (syntax_get stx 2))))

(check === (let ((x 3)) (join (+ 10 x) (x))) 16)


//============================================================================
// syntax_subseq

(define_syntax from1
  (lambda (stx)
    (syntax_subseq (syntax_get stx 1) 1)))

(check === (from1 (ignored + 2 3)) 5)

(define_syntax prepend_from1
  (lambda (stx)
    (syntax_append (quasisyntax (+ 1)) (syntax_subseq (syntax_get stx 1) 1))))

// Test syntax_subseq with index over size
(check === (prepend_from1 (2 3)) 4)
(check === (prepend_from1 (2  )) 1)
(check === (prepend_from1 (   )) 1)


//============================================================================
// Hygiene tests

// Macro must not capture bindings from outside.

(define_syntax dont_capture
  (lambda (stx)
    (quasisyntax
      (let ((x 9))
        (unsyntax (syntax_get stx 1))))))

(check === (let ((x 3)) (dont_capture x)) 3)


// Macro use must not capture bindings from inside the macro.

(define_syntax or2 // 2-part or
  (lambda (stx)
    (let ((e1 (syntax_get stx 1))
          (e2 (syntax_get stx 2)))
      (quasisyntax
        (let ((t (unsyntax e1))) (if t t (unsyntax e2)))))))

(check === (let ((t true) (if false)) (or2 if t)) true)


// Macro-defining macros require multiple syntax marks to maintain hygiene.

(define_syntax make_plus_N  // usage: (make_plus_N name n)
  (lambda (stx)
    (let ((name (syntax_get stx 1))
          (n    (syntax_get stx 2)))
      (quasisyntax
        (define_syntax (unsyntax name)  // usage: (name init)
          (lambda (stx1)
            (let ((init (syntax_get stx1 1)))
              (quasisyntax
                (let ((x (unsyntax init)))
                  (+ x (unsyntax (quote_syntax (unsyntax n)))))))))))))

(make_plus_N plus10 10)

(check === (plus10 3) 13)


//============================================================================
// Breaking hygiene via datum_to_syntax

(define_syntax capture  // capture use of 'c'
  (lambda (stx)
    (let ((arg (syntax_get stx 1)))
      (quasisyntax
        (let ((c 2))
          (unsyntax (datum_to_syntax arg (quote_syntax here))))))))
(check ===
  (let ((c 5))
    (capture (* 10 c)))
  20)


"PASSED" // Helpful output if you run this stand-alone
