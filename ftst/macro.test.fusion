// Copyright (c) 2012-2014 Amazon.com, Inc.  All rights reserved.

(require
  "/fusion/experimental/check"
  "/fusion/experimental/syntax")


// Very basic macro
(define_syntax S1
  (lambda (stx) (quote_syntax 99)))

(check === 99 (S1))


// Test use of macro as body of define_syntax
(define_syntax S2
  (let ((xform (lambda (stx) (quote_syntax 99))))
    xform))

(check === 99 (S2))


// (D v i) => (define i (lambda () v))
(define_syntax D
  (lambda (stx)
    (quasisyntax
      (define (unsyntax (syntax_get stx 2))
        (lambda () (unsyntax (syntax_get stx 1)))))))

(D 67 x)
(check === 67 (x))


// Macro inside of unsyntax
(define_syntax D2
  (lambda (stx)
    (quasisyntax
      ( + 2 (unsyntax (let ((x (quote_syntax 220)))
                        (quasisyntax (unsyntax x))))))))
(check === 222 (D2))


// Macro with tail call
(define s3
  (lambda () (quote_syntax 99)))
(define_syntax S3
  (lambda (stx) (apply s3 [])))
(check === 99 (S3))


//============================================================================
// identifier bindings

(define_syntax fie
  (lambda (stx)
    (let ((id1 (syntax_get stx 1))
          (id2 (syntax_get stx 2)))
      (if (free_identifier_equal id1 id2)
        (quote_syntax true)
        (quote_syntax false)))))
(check_true  (fie < <) )
(check_false (fie < >))
(check_true  (fie unbound unbound))

// Generate two identifiers with the same name but different marks.
// They are not free_identifier_equal because of those marks.
(define_syntax make_id
  (lambda (stx)
    (quote_syntax
      (let ((id "dummy"))       // Each use of make_id makes a fresh id
        (quote_syntax id)))))
(define_syntax compare_diff_ids
  (lambda (stx)
    (let ((id1 (make_id))
          (id2 (make_id)))
      (quasisyntax (fie (unsyntax id1) (unsyntax id2))))))
(check_false (compare_diff_ids))


//============================================================================
// syntax_append

(define_syntax join
  (lambda (stx)
    (syntax_append (syntax_get stx 1) (syntax_get stx 2))))

(check === 16
  (let ((x 3)) (join (+ 10 x) (x))))


//============================================================================
// syntax_subseq

(define_syntax from1
  (lambda (stx)
    (syntax_subseq (syntax_get stx 1) 1)))

(check === 5
  (from1 (ignored + 2 3)) 5)

(define_syntax prepend_from1
  (lambda (stx)
    (syntax_append (quasisyntax (+ 1)) (syntax_subseq (syntax_get stx 1) 1))))

// Test syntax_subseq with index over size
(check === 4 (prepend_from1 (2 3)))
(check === 1 (prepend_from1 (2  )))
(check === 1 (prepend_from1 (   )))


//============================================================================
// Hygiene tests

// Macro must not capture bindings from outside.

(define_syntax dont_capture
  (lambda (stx)
    (quasisyntax
      (let ((x 9))
        (unsyntax (syntax_get stx 1))))))

(check === 3
  (let ((x 3)) (dont_capture x)))


// Macro use must not capture bindings from inside the macro.

(define_syntax or2 // 2-part or
  (lambda (stx)
    (let ((e1 (syntax_get stx 1))
          (e2 (syntax_get stx 2)))
      (quasisyntax
        (let ((t (unsyntax e1))) (if t t (unsyntax e2)))))))

(check_true (let ((t true) (if false)) (or2 if t)))


// Macro-defining macros require multiple syntax marks to maintain hygiene.

(define_syntax make_plus_N  // usage: (make_plus_N name n)
  (lambda (stx)
    (let ((name (syntax_get stx 1))
          (n    (syntax_get stx 2)))
      (quasisyntax
        (define_syntax (unsyntax name)  // usage: (name init)
          (lambda (stx1)
            (let ((init (syntax_get stx1 1)))
              (quasisyntax
                (let ((x (unsyntax init)))
                  (+ x (unsyntax (quote_syntax (unsyntax n)))))))))))))

(make_plus_N plus10 10)

(check === 13 (plus10 3))


//============================================================================
// Breaking hygiene via datum_to_syntax

(define_syntax capture  // capture use of 'c'
  (lambda (stx)
    (lets [(arg (syntax_get stx 1)),
           // TODO FUSION-329 Use entire arg, not first elt, as context
           (ctx (syntax_get arg 0)),
           (c   (datum_to_syntax (quote c) ctx))]
      (quasisyntax
        (let [((unsyntax c) 2)]
          (unsyntax (datum_to_syntax arg (quote_syntax here))))))))

(check === 20
  (let ((c 5))
    (capture (* 10 c))))


"PASSED" // Helpful output if you run this stand-alone
