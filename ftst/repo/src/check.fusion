// Copyright (c) 2012-2013 Amazon.com, Inc.  All rights reserved.

(module check "/fusion"

  (require
    "/fusion/eval"
    "/fusion/exception"
    "/fusion/experimental/defines"
    "/fusion/experimental/syntax"
    "/fusion/ffi/java"
    "/fusion/parameter")

  (provide assert)


  (defpub F (lambda rest false))
  (defpub T (lambda rest true))

  (defpub NULL_SEXP   (quote null.sexp))
  (defpub NULL_SYMBOL (quote null.symbol))

  (defpub is_true
    (lambda (value)
      (and (is_bool value) (= true value))))

  (defpub is_false
    (lambda (value)
      (and (is_bool value) (= false value))))

  (defpub ion_equals          (java_new "com.amazon.fusion.IonEqualsProc"))

  // NOT PUBLIC YET
  (define _raise_check_failure (java_new "com.amazon.fusion.CheckFailureProc"))
  (define thunk_throws        (java_new "com.amazon.fusion.ThunkThrowsProc"))

  (define check_syntax_param (make_parameter null))
  (define raise_check_failure
    (lambda args
      (parameterize [(check_syntax_param (head args))]
        (apply _raise_check_failure check_syntax_param (tail args)))))
  (define raise_check_failure_stack
    (lambda message
      '''
Raises a check failure exception, including a stack trace derived from the
`check_syntax_param` marks.
      '''
      (apply _raise_check_failure check_syntax_param message)))


  // TODO fix argument order. Requires (syntax_subseq _ from to)
  (defpub_syntax define_check
    (lambda (stx)
      '''
      (define_check (name message_arg arg ...) body ...)
      '''
      (when (< (syntax_size stx) 3)
        (wrong_syntax stx
          "Bad syntax for define_check: "
          "(define_check (name message_arg arg ...) body ...)"))
      (lets [(bind_stx (syntax_get stx 1)),
             (body_stx (syntax_subseq stx 2)),
             (name_stx    (syntax_get bind_stx 0)),  // TODO type/size check
             (msg_arg_stx (syntax_get bind_stx 1)),
             (arg_stx     (syntax_subseq bind_stx 2)),
             (arg_count   (syntax_size arg_stx)),
             (arg_ct_stx  (datum_to_syntax arg_count)),
             (args_msg_stx (datum_to_syntax (if (= 1 arg_count)
                                              " arg: "
                                              " args: ")))]
        (quasisyntax
          (define_syntax (unsyntax name_stx)
            (lambda (stx1)
              (when (<= (syntax_size stx1) (unsyntax arg_ct_stx))
                (wrong_syntax stx1
                  (unsyntax name_stx)
                  " requires at least " (unsyntax arg_ct_stx)
                  (unsyntax args_msg_stx)))
                  // TODO add sample eg "(check_true val message ...)"
              (let [(msg_stx (syntax_subseq stx1 (+ 1 (unsyntax arg_ct_stx)))),
                    (arg_binding_stx
                       (let loop ((args (syntax_unwrap (quote_syntax (unsyntax arg_stx))))
                                  (i 1))
                         (if (is_empty args)
                           (quote_syntax ())
                           (syntax_append
                             (quasisyntax (((unsyntax (head args))
                                            (unsyntax (syntax_get stx1 i)))))
                             (loop (tail args) (+ 1 i))))))]
                (quasisyntax
                  (let [((unsyntax (quote_syntax (unsyntax msg_arg_stx)))
                         (unsyntax (if (= 0 (syntax_size msg_stx))
                                       (quote_syntax (void))
// TODO handle multiple message parts
                                       (syntax_append
                                         (quote_syntax (lambda ()))
                                         msg_stx))))]
                    (parameterize
                      [(check_syntax_param (quote_syntax (unsyntax stx1)))]
                      (unsyntax
                        (syntax_append
                          (quasisyntax (let (unsyntax arg_binding_stx)))
                          (quote_syntax (unsyntax body_stx))))))))))))))



  (defpub check_equal_annotations
    (lambda (actual expected)
      (check_list_equal (type_annotations actual) (type_annotations expected))))

  (defpub check_equal
    (lambda (actual expected descr)
      (cond

// TODO FUSION-88 should support undef
//        ((is_undef expected)
//         (assert (is_undef actual)
//           descr " not equal.\nActual: " actual "\nExpected: " expected))
        ((is_list expected)
         (check_list_equal actual expected))
        ((is_sexp expected)
         (check_sexp_equal actual expected))
        ((is_void expected)
         (assert (is_void actual)
           descr " not equal.\nActual: " actual "\nExpected: " expected))
        (true
         (assert (= actual expected)
           descr " not equal.\nActual: " actual "\nExpected: " expected)))
      (check_equal_annotations actual expected)))

  (defpub check_list_equal
    (lambda (actual expected)
      (assert (is_list actual) "expected list, received: " actual)
      (assert (= (size actual) (size expected))
        "list lengths don't match. Actual: " actual " Expected: " expected)
      (let loop [(i 0)]
        (when (< i (size actual))
          (check_equal (element actual i) (element expected i)
            (string_append "list element #" (int_to_string i)))
          (loop (+ 1 i))))))

  (defpub check_sexp_equal
    (lambda (actual expected)
      (assert (is_sexp actual) "expected sexp, received: " actual)
      (assert (= (size actual) (size expected))
        "sexp sizes don't match. Actual: " actual " Expected: " expected)
      (let loop
           [(pos 0), (a actual), (e expected)]
        (if (is_void e)
          (assert (is_void a)
            "sexp tails don't match at pos " pos ". Actual: " actual
            " Expected: " expected)
          (begin
            (check_equal (head a) (head e)
              // TODO bad message
              (string_append "sexp element at position " (int_to_string pos)))
            (loop (+ 1 pos) (tail a) (tail e)))))))


  (defpub check_annotations
    (lambda (value expected)
      (let [(expected (map string_to_symbol expected)),
            (anns (type_annotations value))]
        (check_list_equal anns expected))))


/* This is nowhere near working yet...
  (defpub_syntax define_simple_check
    (lambda (stx)
      (let [(bindings (syntax_get stx 1)),
            (body_sexp (syntax_subseq stx 2))]
        (let [(name (syntax_get bindings 0)),
              (params (syntax_subseq bindings 1)),
              (body_begin (syntax_cons_q begin body_sexp))]

          (quasisyntax
            (define (unsyntax name)
              (lambda (stx)

              )))))))
*/



  (provide check)
  (define_check (check message op val1 val2)
    (unless (op val1 val2)
      (raise_check_failure_stack
        (if message (message) "Operation failure.")
        "\n  operation: " op
        "\n  arguments: " val1
        "\n             " val2)))


  (provide check_pred)
  (define_check (check_pred message pred val)
    (unless (pred val)
      (raise_check_failure_stack
        (if message (message) "Predicate failure.")
        "\n  predicate: " pred
        "\n  argument : " val)))


  (provide check_true)
  (define_check (check_true message val)
    (unless (is_true val)
      (raise_check_failure_stack
        (if message (message) "Expected `true`.")
        " Received: "
        val)))

  (provide check_false)
  (define_check (check_false message val)
    (unless (is_false val)
      (raise_check_failure_stack
        (if message (message) "Expected `false`.")
        " Received: "
        val)))

  (provide check_void)
  (define_check (check_void message val)
    (unless (is_void val)
      (raise_check_failure_stack
        (if message (message) "Expected `void`.")
        " Received: "
        val)))


  // TODO this should accept a predicate to check exn type
  // TODO why doesn't this auto-thunk its body?
  (defpub_syntax check_exn
    (lambda (stx)
      // TODO check arity
      (let [(thunk_stx (syntax_get stx 1))]
        (quasisyntax
          // TODO type-check thunk
          (let [(e (thunk_throws (unsyntax thunk_stx)))]
            (cond
              ((and (is_string e) (= e "syntax"))
               (void))
              (e  (raise_check_failure (quote_syntax (unsyntax stx))
                    "expected syntax failure, got " e " exception"))
              (true (raise_check_failure (quote_syntax (unsyntax stx))
                      "expected syntax failure"))))))))

  // This should really be a procedure, but it doesn't work.
  (define_syntax make_exn_checker
    (lambda (stx)
      (let [(tag (syntax_get stx 1))]
        (quasisyntax
          (lambda (stx)
            // TODO check arity
            (let [(thunk_stx (syntax_get stx 1)),
                  (exn_tag (quote_syntax (unsyntax tag)))]
              (quasisyntax
                // TODO type-check thunk
                (let [(e (thunk_throws (lambda () (unsyntax thunk_stx))))]
                  (cond
                    ((and (is_string e) (= e (unsyntax exn_tag)))
                     (void))
                    (e  (raise_check_failure (quote_syntax (unsyntax stx))
                          "expected " (unsyntax exn_tag) " failure, got "
                          e " exception"))
                    (true (raise_check_failure (quote_syntax (unsyntax stx))
                            "expected " (unsyntax exn_tag) " failure")))))))))))

  (defpub_syntax check_arg_exn
    (make_exn_checker "arg"))

  (defpub_syntax check_arity_exn
    (make_exn_checker "arity"))

  (defpub_syntax check_contract_exn
    (make_exn_checker "contract"))

  (defpub_syntax check_syntax_exn
    (make_exn_checker "syntax"))


  (defpub_syntax check_compile_exn
    '''
    (check_compile_exn top_form)
     ->
    (check_exn (lambda () (eval (quote top_form))))
    '''
    (lambda (stx)
      // TODO check arity
      (let [(top_form (syntax_get stx 1))]
        (quasisyntax
          (check_exn
            (lambda () (eval (quote_syntax (unsyntax top_form)))))))))
)
