// Copyright (c) 2012-2014 Amazon.com, Inc.  All rights reserved.

(module check "/fusion"

  (require
    "/fusion/eval"
    "/fusion/exception"
    "/fusion/experimental/defines"
    "/fusion/experimental/equality"
    "/fusion/experimental/syntax"
    "/fusion/ffi/java"
    "/fusion/parameter")

  (provide assert)


  (defpub F (lambda rest false))
  (defpub T (lambda rest true))

  (defpub NULL_SYMBOL (quote null.symbol))
  (defpub NULL_SEXP   (quote null.sexp))
  (defpub EMPTY_SEXP  (quote ()))

  (defpub VOID  (void))
  (defpub UNDEF (letrec [(x y), (y 1)] x))



  // NOT PUBLIC YET
  (define _raise_check_failure (java_new "com.amazon.fusion.CheckFailureProc"))
  (define thunk_throws        (java_new "com.amazon.fusion.ThunkThrowsProc"))

  (define check_syntax_param (make_parameter null))
  (define raise_check_failure
    (lambda args
      (parameterize [(check_syntax_param (head args))]
        (apply _raise_check_failure check_syntax_param (tail args)))))
  (define raise_check_failure_stack
    (lambda message
      '''
Raises a check failure exception, including a stack trace derived from the
`check_syntax_param` marks.
      '''
      (apply _raise_check_failure check_syntax_param message)))


  // TODO fix argument order. Requires (syntax_subseq _ from to)
  (defpub_syntax define_check
    (lambda (stx)
      '''
    (define_check (name message_arg arg ...) body ...)

Creates a macro that's invoked as:

    (name arg_expr ... message_expr)

(At present, multiple `message_expr`s can be given, but only the last is used.)

That expands to:

    (let [(message_arg (lambda () message_expr))] // or (void) if no message
      (parameterize
        [(check_syntax_param ORIGINAL_SYNTAX)]
        (let [(arg arg_expr), ... ]
          body ...))))

The outer `let` has the effect of avoiding evaluation of the `message_expr`
unless it is required.  It's also a bit odd to use.
      '''
      (when (< (syntax_size stx) 3)
        (wrong_syntax stx
          "Bad syntax for define_check: "
          "(define_check (name message_arg arg ...) body ...)"))
      (lets [(bind_stx (syntax_get stx 1)),
             (body_stx (syntax_subseq stx 2)),
             (name_stx    (syntax_get bind_stx 0)),  // TODO type/size check
             (msg_arg_stx (syntax_get bind_stx 1)),
             (arg_stx     (syntax_subseq bind_stx 2)),
             (arg_count   (syntax_size arg_stx)),
             (arg_ct_stx  (datum_to_syntax arg_count)),
             (args_msg_stx (datum_to_syntax (if (= 1 arg_count)
                                              " arg: "
                                              " args: ")))]
        (quasisyntax
          (define_syntax (unsyntax name_stx)
            (lambda (stx1)
              (when (<= (syntax_size stx1) (unsyntax arg_ct_stx))
                (wrong_syntax stx1
                  (unsyntax name_stx)
                  " requires at least " (unsyntax arg_ct_stx)
                  (unsyntax args_msg_stx)))
                  // TODO add sample eg "(check_true val message ...)"
              (let [(msg_stx (syntax_subseq stx1 (+ 1 (unsyntax arg_ct_stx)))),
                    (arg_binding_stx
                       (let loop ((args (syntax_unwrap (quote_syntax (unsyntax arg_stx))))
                                  (i 1))
                         (if (is_empty args)
                           (quote_syntax ())
                           (syntax_append
                             (quasisyntax (((unsyntax (head args))
                                            (unsyntax (syntax_get stx1 i)))))
                             (loop (tail args) (+ 1 i))))))]
                (quasisyntax
                  (let [((unsyntax (quote_syntax (unsyntax msg_arg_stx)))
                         (unsyntax (if (= 0 (syntax_size msg_stx))
                                       (quote_syntax (void))
// TODO handle multiple message parts
                                       (syntax_append
                                         (quote_syntax (lambda ()))
                                         msg_stx))))]
                    (parameterize
                      [(check_syntax_param (quote_syntax (unsyntax stx1)))]
                      (unsyntax
                        (syntax_append
                          (quasisyntax (let (unsyntax arg_binding_stx)))
                          (quote_syntax (unsyntax body_stx))))))))))))))



/* This is nowhere near working yet...
  (defpub_syntax define_simple_check
    (lambda (stx)
      (let [(bindings (syntax_get stx 1)),
            (body_sexp (syntax_subseq stx 2))]
        (let [(name (syntax_get bindings 0)),
              (params (syntax_subseq bindings 1)),
              (body_begin (syntax_cons_q begin body_sexp))]

          (quasisyntax
            (define (unsyntax name)
              (lambda (stx)

              )))))))
*/



  (provide check)
  (define_check (check message op val1 val2)
    (unless (op val1 val2)
      (raise_check_failure_stack
        (if message (message) "Operation failure.")
        "\n  operation: " op
        "\n  arguments: " val1
        "\n             " val2)))


  (provide check_pred)
  (define_check (check_pred message pred val)
    (unless (pred val)
      (raise_check_failure_stack
        (if message (message) "Predicate failure.")
        "\n  predicate: " pred
        "\n  argument : " val)))


  (provide check_true)
  (define_check (check_true message val)
    (unless (= true val)
      (raise_check_failure_stack
        (if message (message) "Expected true.")
        " Received: "
        val)))

  (provide check_false)
  (define_check (check_false message val)
    (unless (= false val)
      (raise_check_failure_stack
        (if message (message) "Expected false.")
        " Received: "
        val)))

  (provide check_void)
  (define_check (check_void message val)
    (unless (is_void val)
      (raise_check_failure_stack
        (if message (message) "Expected void.")
        " Received: "
        val)))


  (provide check_annotations)
  (define_check (check_annotations msg value expected)
    (check = (type_annotations value) expected))


  // TODO this should accept a predicate to check exn type
  // TODO why doesn't this auto-thunk its body?
  (defpub_syntax check_exn
    (lambda (stx)
      // TODO check arity
      (let [(thunk_stx (syntax_get stx 1))]
        (quasisyntax
          // TODO type-check thunk
          (let [(e (thunk_throws (unsyntax thunk_stx)))]
            (cond
              ((== e "syntax")
               (void))
              (e  (raise_check_failure (quote_syntax (unsyntax stx))
                    "expected syntax failure, got " e " exception"))
              (true (raise_check_failure (quote_syntax (unsyntax stx))
                      "expected syntax failure"))))))))

  // This should really be a procedure, but it doesn't work.
  (define_syntax make_exn_checker
    (lambda (stx)
      (let [(tag (syntax_get stx 1))]
        (quasisyntax
          (lambda (stx)
            // TODO check arity
            (let [(thunk_stx (syntax_get stx 1)),
                  (exn_tag (quote_syntax (unsyntax tag)))]
              (quasisyntax
                // TODO type-check thunk
                (let [(e (thunk_throws (lambda () (unsyntax thunk_stx))))]
                  (cond
                    ((== e (unsyntax exn_tag))
                     (void))
                    (e  (raise_check_failure (quote_syntax (unsyntax stx))
                          "expected " (unsyntax exn_tag) " failure, got "
                          e " exception"))
                    (true (raise_check_failure (quote_syntax (unsyntax stx))
                            "expected " (unsyntax exn_tag) " failure")))))))))))

  (defpub_syntax check_arg_exn
    (make_exn_checker "arg"))

  (defpub_syntax check_arity_exn
    (make_exn_checker "arity"))

  (defpub_syntax check_contract_exn
    (make_exn_checker "contract"))

  (defpub_syntax check_syntax_exn
    (make_exn_checker "syntax"))


  (defpub_syntax check_compile_exn
    '''
    (check_compile_exn top_form)
     ->
    (check_exn (lambda () (eval (quote top_form))))
    '''
    (lambda (stx)
      // TODO check arity
      (let [(top_form (syntax_get stx 1))]
        (quasisyntax
          (begin
            (check_exn
              (lambda () (eval (quote_syntax (unsyntax top_form)))))
            (check_exn
              (lambda () (eval (quote (unsyntax top_form))))))))))



  (defpub all_nulls
    (quote (null
            null.bool
            null.int
            null.float
            null.decimal
            null.timestamp
            null.symbol
            null.string
            null.clob
            null.blob
            null.list
            null.sexp
            null.struct)))

  (defpub representative_ion_data
    (quote (null

            null.bool
            true
            false

            null.int
            0
            123456

            null.float
            -0e0
            0e0
            2.56e0

            null.decimal
            -0d0
            0d0
            2.57

            null.timestamp
            2013-02-08T

            null.symbol
//          ''                   // TODO FUSION-204 empty symbol
            symbol

            null.string
            ""
            "a real string"

            null.clob
            {{""}}
            {{"a real clob"}}

            null.blob
            {{}}
            {{abcd}}

            null.list
            []
            [1]
            [1,2]

            null.sexp
            ()
            (1)
            (1 2)

            null.struct
            {}
            {f:1}
            {f:1, g:2})))


  (defpub_syntax check_representative_ion_data
    (lambda (stx)
      '''
      (check_representative_ion_data FORM)

Maps the given syntactic form over each entry in `representative_ion_data`.
      '''
      (let [(form_stx (syntax_get stx 1))]
        (syntax_cons_q begin
          (let loop [(data representative_ion_data)]
            (if (is_empty data)
              (quote_syntax ())
              (let [(datum_stx (datum_to_syntax (head data)))]
                (syntax_append
                  (quasisyntax (((unsyntax form_stx) (unsyntax datum_stx))))
                  (loop (tail data))))))))))
)
