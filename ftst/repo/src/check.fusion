// Copyright (c) 2012-2013 Amazon.com, Inc.  All rights reserved.

(module check "/fusion"

  (require
    "/fusion/eval"
    "/fusion/exception"
    "/fusion/experimental/defines"
    "/fusion/experimental/syntax"
    "/fusion/ffi/java")

  (provide assert)


  (defpub F (lambda rest false))
  (defpub T (lambda rest true))


  (defpub ion_equals          (java_new "com.amazon.fusion.IonEqualsProc"))

  // NOT PUBLIC YET
  (define raise_check_failure (java_new "com.amazon.fusion.CheckFailureProc"))
  (define thunk_throws        (java_new "com.amazon.fusion.ThunkThrowsProc"))


  (defpub check_equal_annotations
    (lambda (actual expected)
      (check_list_equal (type_annotations actual) (type_annotations expected))))

  (defpub check_equal
    (lambda (actual expected descr)
      (cond

// TODO FUSION-88 should support undef
//        ((is_undef expected)
//         (assert (is_undef actual)
//           descr " not equal.\nActual: " actual "\nExpected: " expected))
        ((is_list expected)
         (check_list_equal actual expected))
        ((is_sexp expected)
         (check_sexp_equal actual expected))
        ((is_void expected)
         (assert (is_void actual)
           descr " not equal.\nActual: " actual "\nExpected: " expected))
        (true
         (assert (= actual expected)
           descr " not equal.\nActual: " actual "\nExpected: " expected)))
      (check_equal_annotations actual expected)))

  (defpub check_list_equal
    (lambda (actual expected)
      (assert (is_list actual) "expected list, received: " actual)
      (assert (= (size actual) (size expected))
        "list lengths don't match. Actual: " actual " Expected: " expected)
      (let loop ((i 0))
        (when (< i (size actual))
          (check_equal (element actual i) (element expected i)
            (string_append "list element #" (int_to_string i)))
          (loop (+ 1 i))))))

  (defpub check_sexp_equal
    (lambda (actual expected)
      (assert (is_sexp actual) "expected sexp, received: " actual)
      (assert (= (size actual) (size expected))
        "sexp sizes don't match. Actual: " actual " Expected: " expected)
      (let loop
           [(pos 0), (a actual), (e expected)]
        (if (is_void e)
          (assert (is_void a)
            "sexp tails don't match at pos " pos ". Actual: " actual
            " Expected: " expected)
          (begin
            (check_equal (head a) (head e)
              // TODO bad message
              (string_append "sexp element at position " (int_to_string pos)))
            (loop (+ 1 pos) (tail a) (tail e)))))))


  (defpub check_annotations
    (lambda (value expected)
      (let [(expected (map string_to_symbol expected)),
            (anns (type_annotations value))]
        (check_list_equal anns expected))))


/* This is nowhere near working yet...
  (defpub_syntax define_simple_check
    (lambda (stx)
      (let ((bindings (syntax_get stx 1))
            (body_sexp (syntax_subseq stx 2)))
        (let ((name (syntax_get bindings 0))
              (params (syntax_subseq bindings 1))
              (body_begin (syntax_cons_q begin body_sexp)))

          (quasisyntax
            (define (unsyntax name)
              (lambda (stx)

              )))))))
*/

  (define_syntax do_check  // private
    (lambda (stx)
      '''
(do_check ORIG_STX OP VAL1 VAL2 MSG ...)

Ensures that (OP VAL1 VAL2) is truthy.
      '''
      (let ((orig_stx (syntax_get stx 1))
            (op_stx   (syntax_get stx 2))
            (val1_stx (syntax_get stx 3))
            (val2_stx (syntax_get stx 4))
            (msg_sexp (syntax_subseq stx 5)))
        (quasisyntax
          (let ((op   (unsyntax op_stx))
                (val1 (unsyntax val1_stx))
                (val2 (unsyntax val2_stx)))
            (unless (op val1 val2)
              (unsyntax
                (syntax_append
                  (quasisyntax
                    (raise_check_failure
                      (quote_syntax (unsyntax orig_stx))))
                  msg_sexp
                  (quasisyntax
                    ("\n params:\n  " op
                     "\n  " val1
                     "\n  " val2))))))))))

  (defpub_syntax check
    (lambda (stx)
      '''
(check OP VAL1 VAL2 MSG ...)

Ensures that (OP VAL1 VAL2) is truthy.
      '''
      (when (< (syntax_size stx) 4)
        (wrong_syntax stx "check requires at least three args: (check OP VAL1 VAL2 MSG ...)"))
      (syntax_append
        (quasisyntax (do_check (unsyntax stx)))
        (syntax_subseq stx 1))))


  (defpub_syntax check_pred
    (lambda (stx)
      '''
(check_pred PRED VAL MSG ...)

Ensures that (PRED VAL) is truthy.
      '''
      (when (< (syntax_size stx) 3)
        (wrong_syntax stx
          "check_pred requires at least two args: (check_pred PRED VAL MSG ...)"))
      (syntax_append
        (quasisyntax
          (do_check (unsyntax stx)
            (lambda (result dummy)
              ((unsyntax (syntax_get stx 1)) result))
            (unsyntax (syntax_get stx 2))
            "(ignore this dummy argument)"))
        (syntax_subseq stx 3))))


  // The failure message isn't the greatest, its in terms of the inner check
  (defpub_syntax check_true
    (lambda (stx)
      (let ((val1_stx (syntax_get stx 1))
            (msg_sexp (syntax_subseq stx 2)))
        (syntax_append
          (quasisyntax
            (do_check (unsyntax stx) = (unsyntax val1_stx) true))
          msg_sexp))))


  // The failure message isn't the greatest, its in terms of the inner check
  (defpub_syntax check_false
    (lambda (stx)
      (let ((val1_stx (syntax_get stx 1))
            (msg_sexp (syntax_subseq stx 2)))
        (syntax_append
          (quasisyntax
            (do_check (unsyntax stx) = (unsyntax val1_stx) false))
          msg_sexp))))


  // The failure message isn't the greatest, its in terms of the inner check
  (defpub_syntax check_void
    (lambda (stx)
      (let ((val1_stx (syntax_get stx 1))
            (msg_sexp (syntax_subseq stx 2)))
        (syntax_append
          (quasisyntax
            (do_check (unsyntax stx) (lambda (actual expected) (is_void actual))
              (unsyntax val1_stx) false))
          msg_sexp))))


  // TODO this should accept a predicate to check exn type
  // TODO why doesn't this auto-thunk its body?
  (defpub_syntax check_exn
    (lambda (stx)
      // TODO check arity
      (let [(thunk_stx (syntax_get stx 1))]
        (quasisyntax
          // TODO type-check thunk
          (let ((e (thunk_throws (unsyntax thunk_stx))))
            (cond
              ((and (is_string e) (= e "syntax"))
               (void))
              (e  (raise_check_failure (quote_syntax (unsyntax stx))
                    "expected syntax failure, got " e " exception"))
              (true (raise_check_failure (quote_syntax (unsyntax stx))
                      "expected syntax failure"))))))))

  // This should really be a procedure, but it doesn't work.
  (define_syntax make_exn_checker
    (lambda (stx)
      (let [(tag (syntax_get stx 1))]
        (quasisyntax
          (lambda (stx)
            // TODO check arity
            (let ((thunk_stx (syntax_get stx 1))
                  (exn_tag (quote_syntax (unsyntax tag))))
              (quasisyntax
                // TODO type-check thunk
                (let ((e (thunk_throws (lambda () (unsyntax thunk_stx)))))
                  (cond
                    ((and (is_string e) (= e (unsyntax exn_tag)))
                     (void))
                    (e  (raise_check_failure (quote_syntax (unsyntax stx))
                          "expected " (unsyntax exn_tag) " failure, got "
                          e " exception"))
                    (true (raise_check_failure (quote_syntax (unsyntax stx))
                            "expected " (unsyntax exn_tag) " failure")))))))))))

  (defpub_syntax check_arg_exn
    (make_exn_checker "arg"))

  (defpub_syntax check_arity_exn
    (make_exn_checker "arity"))

  (defpub_syntax check_contract_exn
    (make_exn_checker "contract"))

  (defpub_syntax check_syntax_exn
    (make_exn_checker "syntax"))


  (defpub_syntax check_compile_exn
    '''
    (check_compile_exn top_form)
     ->
    (check_exn (lambda () (eval (quote top_form))))
    '''
    (lambda (stx)
      // TODO check arity
      (let [(top_form (syntax_get stx 1))]
        (quasisyntax
          (check_exn
            (lambda () (eval (quote_syntax (unsyntax top_form)))))))))
)
