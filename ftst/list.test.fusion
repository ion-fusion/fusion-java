// Copyright (c) 2012-2014 Amazon.com, Inc.  All rights reserved.

(require
  "/check"
  "/fusion/experimental/equality"
  "/fusion/list"
  "/fusion/private/builtins"  // annotate
  "/fusion/unsafe/list")


(define _list_copy
  (lambda (ctor v)
    (apply annotate
      (if (is_null v)
        v
        (apply ctor v))
      (type_annotations v))))

(define list_copy
  (lambda (v)
    (_list_copy list v)))

(define mutable_list_copy
  (lambda (v)
    (_list_copy mutable_list v)))

(define stretchy_list_copy
  (lambda (v)
    (_list_copy stretchy_list v)))


(define_check (check_mod_f msg op val args expect)
  "Functional modification check"
  (let [(v (list_copy val))]
    (let [(result (apply op v args))]
      (check_pred is_immutable_list result
        "result of " op " should be immutable")
      (check === result expect
        "Unexpected result from " op " on immutable arg")
      (check === v val                                 // v not mutated
        "Immutable arg was mutated by " op)))
  (unless (is_null val)                             // There's no mutable null
    (let [(v (mutable_list_copy val))]
      (let [(result (apply op v args))]
        (check_pred is_mutable_list result
          "result of " op " should be mutable")
        (check === result expect
          "Unexpected result from " op " on mutable " v)
        (check === v val                               // v not mutated
          "Mutable arg was mutated by " op)
        (unless (is_empty val)
          (list_set result 0 "mod")
          (check === v val "Unexpected mutation of original"))))
    (let [(v (stretchy_list_copy val))]
      (let [(result (apply op v args))]
        (check_pred is_stretchy_list result
          "result of " op " should be stretchy")
        (check === result expect
          "Unexpected result from " op " on stretchy " v)
        (check === v val                               // v not mutated
          "Stretchy arg was mutated by " op)
        (add_m result "stretch")
        (check === v val "Unexpected mutation of original")
        (unless (is_empty val)
          (list_set result 0 "mod")
          (check === v val "Unexpected mutation of original"))))))



//==========================================================================
// Literals

(check_true (is_null  null.list))
(check_true (is_empty null.list))
(check_true (is_null  (quote null.list)))
(check_true (is_empty (quote null.list)))
(check_true (is_null  (quote a::null.list)))
(check_true (is_empty (quote a::null.list)))

(check_false (is_null []))
(check_false (is_null (quote [])))
(check_false (is_null (quote a::[])))


(check_annotations (quote []) (quote []))
(check_annotations (quote a::[]) (quote ["a"]))
(check_annotations (quote a::b::[]) (quote ["a","b"]))
(check_annotations (quote a::b::a::[]) (quote ["a","b","a"]))

(assert (not (is_list           (quote ()))))
(assert (not (is_mutable_list   (quote ()))))
(assert (not (is_immutable_list (quote ()))))
(assert (not (is_stretchy_list  (quote ()))))


//==========================================================================
// Constructors and Predicates

(define test_predicates
  (lambda (list mutable stretchy)
    (assert (is_list list))
    (check = (is_mutable_list   list) mutable)
    (check = (is_immutable_list list) (not mutable))
    (check = (is_stretchy_list  list) stretchy)))


// Construction via literals

(define x "anything")

(test_predicates []     false false)
(test_predicates [0]    false false)
(test_predicates [0, T] false false)

(test_predicates (quote [])     false false)
(test_predicates (quote [0])    false false)
(test_predicates (quote [0, T]) false false)


// Construction via procedures

(define test_makers
  (lambda (maker mutable stretchy)
    (test_predicates (apply maker (quote ())) mutable stretchy)
    (test_predicates (apply maker (quote (0))) mutable stretchy)
    (check === (apply maker (quote ()))
      [])
    (check === (apply maker (quote (0 1)))
      [0, 1])))

(test_makers list false false)
(test_makers mutable_list true false)
(test_makers stretchy_list true true)


//==========================================================================
// annotate

(check_mod_f annotate null.list []                      null.list)
(check_mod_f annotate null.list ["a"]      (quote a::   null.list))
(check_mod_f annotate null.list ["a", "b"] (quote a::b::null.list))

(check_mod_f annotate [] []                      [])
(check_mod_f annotate [] ["a"]      (quote a::   []))
(check_mod_f annotate [] ["a", "b"] (quote a::b::[]))

(check_mod_f annotate [1] []                      [1])
(check_mod_f annotate [1] ["a"]      (quote a::   [1]))
(check_mod_f annotate [1] ["a", "b"] (quote a::b::[1]))


// Replacing existing annotations
(check_mod_f annotate (quote x::null.list) ["a"]      (quote a::null.list))
(check_mod_f annotate (quote x::null.list) ["a", "b"] (quote a::b::null.list))

(check_mod_f annotate (quote x::[]) []                      [])
(check_mod_f annotate (quote x::[]) ["a"]      (quote a::   []))
(check_mod_f annotate (quote x::[]) ["a", "b"] (quote a::b::[]))

(check_mod_f annotate (quote x::[1]) []                      [1])
(check_mod_f annotate (quote x::[1]) ["a"]      (quote a::   [1]))
(check_mod_f annotate (quote x::[1]) ["a", "b"] (quote a::b::[1]))


(check_arg_exn (annotate null.list null))
(check_arg_exn (annotate null.list ""))
(check_arg_exn (annotate null.list null.string))
(check_arg_exn (annotate null.list (quote null.symbol)))
(check_arg_exn (annotate null.list 12))


//==========================================================================
// size

(define imm0 [])
(define imm1 [0])
(define imm2 [0, [1]])

(define mut0 (mutable_list))
(define mut1 (mutable_list 0))
(define mut2 (mutable_list 0 [1]))

(define str0 (stretchy_list))
(define str1 (stretchy_list 0))
(define str2 (stretchy_list 0 [1]))


(check === (size imm0) 0)
(check === (size mut0) 0)
(check === (size str0) 0)

(check === (size imm1) 1)
(check === (size mut1) 1)
(check === (size str1) 1)

(check === (unsafe_list_size imm2) 2)
(check === (unsafe_list_size mut2) 2)
(check === (unsafe_list_size str2) 2)


//==========================================================================
// has_key

(check_false (has_key null.list ""))
(check_false (has_key null.list null.int))
(check_false (has_key null.list -1))
(check_false (has_key null.list 0))
(check_false (has_key null.list 1))

(check_false (has_key [] ""))
(check_false (has_key [] null.int))
(check_false (has_key [] -1))
(check_false (has_key [] 0))
(check_false (has_key [] 1))

(check_false (has_key [1,2,3] null.string))
(check_false (has_key [1,2,3] -1))
(check_false (has_key [1,2,3] 3))

(check_true (has_key [1,2,3] 0))
(check_true (has_key [1,2,3] 1))
(check_true (has_key [1,2,3] 2))

(check_true (has_key [null]   0))
(check_true (has_key [false]  0))
(check_true (has_key [(void)] 0))

(check_arity_exn (has_key))
(check_arity_exn (has_key []))


//==========================================================================
// list_element

(define test_ref
  (lambda (vec2)
    (check = (list_element vec2 0) 0)
    (check = (unsafe_list_element vec2 0) 0)
    (check === (list_element vec2 1)
      [1])
    (check === (list_element vec2 1)
      [1])
    (check === (unsafe_list_element vec2 1)
      [1])))

(test_ref imm2)
(test_ref mut2)
(test_ref str2)


// Lists can hold any type!

(assert ((list_element [F, T] 1)))
(assert ((list_element (mutable_list F T) 1)))
(assert ((list_element (stretchy_list F T) 1)))

// Bad arguments
(check_arg_exn (list_element [1,2] null.int))


//==========================================================================
// list_set

(check === (let [(v (mutable_list 0))]
             (list_set v 0 1)
             v)
  [1])

(check === (let [(v (stretchy_list 0))]
             (list_set v 0 1)
             v)
  [1])


//==========================================================================
// add, add_m

(define test_add
  (lambda (add_proc v0)
    (check_arity_exn (add_proc))
    (check_arity_exn (add_proc []))
    (let [(mutable (is_mutable_list v0)),
          (stretchy (is_stretchy_list v0)),
          (v1 (add_proc v0 1))]
      (test_predicates v1 mutable stretchy)
      (check === v0 [] "v0 not modified")
      (check === v1 [1])
      (let ((v2 (add_proc v1 2)))
        (test_predicates v2 mutable stretchy)
        (check === v0 []      "v0 not modified")
        (check === v1 [1]     "v1 not modified")
        (check === v2 [1, 2])))))

(test_add add [])
(test_add add (list))
(test_add add (mutable_list))
(test_add add (stretchy_list))

(test_add unsafe_list_add [])
(test_add unsafe_list_add (list))
(test_add unsafe_list_add (mutable_list))
(test_add unsafe_list_add (stretchy_list))


(define test_add_m
  (lambda (add_m_proc add_proc v0)
    (check_arity_exn (add_m_proc))
    (let [(mutable (is_mutable_list v0)),
          (stretchy (is_stretchy_list v0)),
          (v1 (add_m_proc v0 1))]
      (test_predicates v1 mutable stretchy)
      (if stretchy
        (check === v0 [1] "v0 should be modified")
        (check === v0 []  "v0 not modified"))
      (check === v1 [1] "v1")
      (let ((v2 (add_m_proc v1 2)))
        (test_predicates v2 mutable stretchy)
        (if stretchy
          (begin
            (check === v0 [1, 2] "v0 should be modified")
            (check === v1 [1, 2] "v1 should be modified")
            )
          (begin
            (check === v0 []  "v0 not modified")
            (check === v1 [1] "v1 not modified")))
        (check === v2 [1, 2])

        // Test that we use the right size when its less than capacity
        (let ((v3 (add_m_proc v2 3)))
          (let ((v4 (add_proc v3 4)))  // NOT add_m!
            (check === v4 [1,2,3,4])))))))


(test_add_m add_m add [])
(test_add_m add_m add (list))
(test_add_m add_m add (mutable_list))
(test_add_m add_m add (stretchy_list))

(test_add_m unsafe_list_add_m unsafe_list_add [])
(test_add_m unsafe_list_add_m unsafe_list_add (list))
(test_add_m unsafe_list_add_m unsafe_list_add (mutable_list))
(test_add_m unsafe_list_add_m unsafe_list_add (stretchy_list))


(check_arg_exn (add_m NULL_SEXP 2))


(define str (stretchy_list 1 2))
(unsafe_list_add_m str 3)
{ a: str }  // Once broken due to the null in the stretchy list after 3


//==========================================================================
// Iteration

(check === (list_from_iterator (list_iterator str))
  [1,2,3])


//==========================================================================
// append_m

(define test_append_m
  (lambda (v0)
    (let [(mutable (is_mutable_list v0)),
          (stretchy (is_stretchy_list v0)),
          (v1 (append_m v0 [1]))]
      (test_predicates v1 mutable stretchy)
      (if stretchy
        (check === v0 [1] "v0 should be modified")
        (check === v0 []  "v0 not modified"))
      (check === v1 [1] "v1")
      (let ((v2 (append_m v1 (stretchy_list 2 3) (mutable_list 4))))
        (test_predicates v2 mutable stretchy)
        (if stretchy
          (begin
            (check === v0 [1, 2, 3, 4] "v0 should be modified")
            (check === v1 [1, 2, 3, 4] "v1 should be modified")
            )
          (begin
            (check === v0 []  "v0 not modified")
            (check === v1 [1] "v1 not modified")))
        (check === v2 [1, 2, 3, 4])))))

(test_append_m [])
(test_append_m (list))
(test_append_m (mutable_list))
(test_append_m (stretchy_list))

(check === (append_m null.list [1] null.list)
  [1])
(check === (append_m [1] null.list)
  [1])


(check === (append_m (quote a::null.list))
  (quote a::null.list))
(check === (append_m (quote a::null.list) (quote b::[c::2]))
  (quote a::[c::2]))

(check === (append_m (quote a::[1]))
  (quote a::[1]))
(check === (append_m (quote a::[1]) (quote b::[c::2]))
  (quote a::[1,c::2]))

// TODO test annotations on mutable/stretchy lists


//==========================================================================
// first

(check_arity_exn (first))
(check_arity_exn (first [1] 2))

(check = (first [1])    1)
(check = (first [1, 2]) 1)

(check_arg_exn (first null.list))
(check_arg_exn (first []))
(check_arg_exn (first "boeing"))


//==========================================================================
// last

(check_arity_exn (last))
(check_arity_exn (last [1] 2))


(check = (last [1])    1)
(check = (last [1, 2]) 2)

(check_arg_exn (last []))
(check_arg_exn (last "boeing"))


//==========================================================================
// find

(assert (is_void (find F null.list)))
(assert (is_void (find F [])))
(assert (is_void (find F [1, 2])))
(check = (find T [1, 2]) 1)

(check === (find (lambda (e) (= e "hi")) ["oh", "hi"]) "hi")


//==========================================================================
// any

(check_false (any T null.list))
(check_false (any T []))
(check_false (any F [1, 2]))
(check_true  (any T [1, 2]))

(check_true  (any (lambda (e) (= e "hi")) ["oh", "hi"]))
(check_false (any (lambda (e) (= e "ho")) ["oh", "hi"]))

// Check that it returns the truthy predicate result, not the selected element
(check = 408
  (any (lambda (e) (when (= e 204) (* e 2)))
    [123, 204, 567]))
(check = 1134
  (any (lambda (e) (when (= e 567) (* e 2)))
    [123, 204, 567]))

// Check that `any` returns the last predicate result if none are truthy
(check_pred (conjoin is_null is_int)
  (any (lambda (s) (if (is_void s) null.int null))
    [false, (void)] ))
(check_pred (conjoin is_null is_int)
  (any (lambda (s) (if (is_null s) null.int null))
    [false, null.bool]))
(check_void
  (any (lambda (s) (if (is_null s) (void) null))
    [false, null.int, null.list]))


//==========================================================================
// every

(check_true (every T null.list))
(check_true (every T []))
(check_false (every F [1, 2]))
(check_true  (every T [1, 2]))

(check_false (every (lambda (e) (= e "hi")) ["oh", "hi"]))
(check_true  (every (lambda (e) (= e "hi")) ["hi", "hi"]))

// Check that it returns the untruthy predicate result
(check_void
  (every (lambda (e) (when (= e 204) e))
    [123, 204, 567]))
(check_pred is_null
  (every (lambda (e) (if (= e 123) e null))
    [123, 456, 678]))

// Check that `every` returns the last predicate result if all are truthy
(check = 1134
  (every (lambda (e) (when (or (= e 123) (= e 567)) (* e 2)))
    [123, 123, 567]))


//==========================================================================
// map

(check === (map + null.list) [])
(check === (map + []) [])
(check === (map + [1, 2]) [1, 2])
(check === (map (lambda (n) (+ 3 n)) [1, 2]) [4, 5])

(check === (choose T null.list) [])
(check === (choose F null.list) [])
(check === (choose T []) [])
(check === (choose F []) [])
(check === (choose T [1, 2]) [1, 2])
(check === (choose F [1, 2]) [])

(check === (choose (lambda (n) (< 10 n)) [1, 11, 10, 12]) [11, 12])


//==========================================================================
// do

(check === (do identity null.list) VOID)
(check === (do (lambda (x) (+ 1 x)) [2, 3]) VOID)

(let [(v (stretchy_list))]
  (do (lambda (x) (add_m v (+ 1 x))) [2, 3])
  (check === v [3, 4]))
