// Copyright (c) 2012-2013 Amazon.com, Inc.  All rights reserved.

(require
  "/check"
  "/fusion/for"
  "/fusion/list")


(check_list_equal
  (for_list () 73)
  [])


(check_list_equal
  (for_list ((e [])) /* no body */)
  [])

(check_list_equal
  (for_list ((e [])) 73)
  [])

(check_list_equal
  (for_list ((e [1])) 73)
  [73])

(check_list_equal
  (for_list ((e [1])) e)
  [1])

(check_list_equal
  (for_list ((e [1, 2, 3])
             (f [1, 2, 3]))
    (+ e f))
  [2, 4, 6])

(check_list_equal
  (for_list ((e [1, 2, 3])
             (f [1, 2]))
    (+ e f))
  [2, 4])


// Sexp works too
(check_list_equal
  (for_list ((e (quote (1 2)))
             (f [1, 2, 3]))
    (+ e f))
  [2, 4])


// Macro in bound-value position
(check_list_equal
  (for_list ((e (let ((list [1])) list))) (+ e 73))
  [74])


// Macro in body position
(check_list_equal
  (for_list ((e [1])) (let ((v 73)) (+ e 73)))
  [74])


// This tests two things:
//  1) non-Ion types in the result; here, closures.
//  2) use of new locations for the bound variables each iteration.
//     The thunks are applied after iteration completes, each one should have
//     its own location for variable `e`.
(check_list_equal
  (map (lambda (thunk) (thunk))
    (for_list ((e [1, 2, 3]))
      (lambda () (* 2 e))))
  [2, 4, 6])



(check_compile_exn (for_list))
(check_compile_exn (for_list 1 2))
(check_compile_exn (for_list null.sexp 13))
(check_compile_exn (for_list (12) 13))
(check_compile_exn (for_list (1 2) 13))
(check_compile_exn (for_list (()) 13))
(check_compile_exn (for_list ((12)) 13))
(check_compile_exn (for_list ((name)) 13))
(check_compile_exn (for_list ((name 1 2)) 13))
(check_compile_exn (for_list ((name 1) ()) 13))
(check_compile_exn (for_list ((name 1) (name2)) 13))


"PASSED" // Helpful output if you run this stand-alone
