// Copyright (c) 2012-2013 Amazon.com, Inc.  All rights reserved.

(require "/check")


(define rester
  (lambda rest
    (assert (is_sexp rest))
    rest))

(check_equal (rester)       (sexp)       "rest param 0")
(check_equal (rester 1)     (sexp 1)     "rest param 1")
(check_equal (rester 1 2 3) (sexp 1 2 3) "rest param 3")

(check_equal (apply rester [])         (sexp)         "apply rester 0")
(check_equal (apply rester [1])        (sexp 1)       "apply rester 1")
(check_equal (apply rester 1 2 [3, 4]) (sexp 1 2 3 4) "apply rester 4")


// Duplicate bound names
(check_compile_exn
  (lambda (x x) true))
(check_compile_exn
  (lambda (x a b c x) true))


//==========================================================================
// set

(check_equal ((lambda (x) (set x (+ x 1)) x) 0) 1 "set1")

(define counter
  (let ((c 0))
    (lambda ()
      (set c (+ 1 c))
      c)))

(check_equal (counter) 1 "counter1")
(check_equal (counter) 2 "counter2")
(check_equal (counter) 3 "counter3")


//==========================================================================
// let

// Duplicate bound names
(check_compile_exn
  (let [(x 1), (b 2), (x 3)] true))


//==========================================================================
// let_values

(check = (let_values [] 1) 1)

(check = (let_values [((x) 1)] x) 1)

(check =
  (let_values
    [((x) 1),
     ((y) (values 2))]
    (+ x y))
  3)

(check =
  (let_values
    [((x) 1),
     ((y) 2),
     ((z) 3)]
    (+ x y z))
  6)

(check =
  // The dummy var ensures that the x vars have different offsets
  (let [(dummy -1), (x 1)]
    (let_values
      [((x) (+ x 2)),
       ((y) (+ x 10))]
      y))
  11)

(check =
  (let_values [(() (values))] 303)
  303)
(check =
  (let [(dummy -1), (x 1)]
    (let_values [((x y) (values 10 x)),
                 ((z p) (values x 100))]
      (+ x y z p)))
  112)


// Duplicate bound names
(check_compile_exn
  (let_values [((x) 1), ((x) 2)] 3))
(check_compile_exn
  (let_values [((x x) (values 1 2))] 3))

// Arity mismatch
(check_contract_exn
  (let_values [(() 1)] 3))
(check_contract_exn
  (let_values [((x) (values))] 3))
(check_contract_exn
  (let_values [((x) (values 1 2 3))] 3))
(check_contract_exn
  (let_values [((x y) (values 1))] 3))
(check_contract_exn
  (let_values [((x y) (values 1 2 3))] 3))
(check_contract_exn
  (let_values [((x) 1), ((y z) (values 1 2 3))] 3))
  
  
//==========================================================================
// letrec

(check = (letrec [] 1) 1)

(when false // TODO FUSION-88 undef should be instance-equal.
(check =
  (letrec [(x y), (y 2)] x)
  (letrec [(a b), (c 3), (b a)] a))
)


// Duplicate bound names
(check_compile_exn
  (letrec [(x 1), (b 2), (x 3)] true))


//==========================================================================
// lets

(check = (lets [] 225) 225)
(check = (lets [(x 226)] x) 226)

(check =
  (let [(x 5)]
    (lets [(x 19), (y (+ x 222))] y))
  (+ 19 222))

(check =
  (lets [(x 19), (y (+ x 222))] y)
  (+ 19 222))


//==========================================================================
// is_undef
//   ... tested here because undef should only come out of letrec

// TODO FUSION-88 undef should be instance-equal.
(define is_undef 1)
(define undef 1)

(when false // TODO FUSION-88 undef should be instance-equal.
(check_equal (is_undef undef)  true  "is_undef undef")
(check_equal (is_undef (void)) false "is_undef void")
(check_equal (is_undef null)   false "is_undef null")
(check_equal (is_undef true)   false "is_undef true")
(check_equal (is_undef false)  false "is_undef false")
(check_equal (is_undef 0)      false "is_undef 0")
(check_equal (is_undef "")     false "is_undef \"\"")
)
