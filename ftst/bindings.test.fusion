// Copyright (c) 2012-2014 Amazon.com, Inc.  All rights reserved.

(require
  "/fusion/experimental/check"
  "/testutils"
)


(define rester
  (lambda rest
    (check_pred is_sexp rest)
    rest))

(check === (sexp)       (rester))
(check === (sexp 1)     (rester 1))
(check === (sexp 1 2 3) (rester 1 2 3))

(check === (sexp)         (apply rester []))
(check === (sexp 1)       (apply rester [1]))
(check === (sexp 1 2 3 4) (apply rester 1 2 [3, 4]))


// Duplicate bound names
(expect_syntax_exn
  (lambda (x x) true))
(expect_syntax_exn
  (lambda (x a b c x) true))


// These expressions crashed due to FUSION-273:
((lambda (t) ((lambda () t))) 1)
(let [(t 1)] ((lambda () t)))
(let [(t 1)] (let_values [] t))


//==========================================================================
// set

(check === 1
  ((lambda (x) (set x (+ x 1)) x) 0))

(define counter
  (let ((c 0))
    (lambda ()
      (set c (+ 1 c))
      c)))

(check === 1 (counter))
(check === 2 (counter))
(check === 3 (counter))


//==========================================================================
// let

// Duplicate bound names
(expect_syntax_exn
  (let [(x 1), (b 2), (x 3)] true))


//==========================================================================
// let_values

(check === 1
  (let_values [] 1))

(check === 1
  (let_values [((x) 1)] x))

(check === 3
  (let_values
    [((x) 1),
     ((y) (values 2))]
    (+ x y)))

(check === 6
  (let_values
    [((x) 1),
     ((y) 2),
     ((z) 3)]
    (+ x y z)))

(check === 11
  // The dummy var ensures that the x vars have different offsets
  (let [(dummy -1), (x 1)]
    (let_values
      [((x) (+ x 2)),
       ((y) (+ x 10))]
      y)))

(check === 303
  (let_values [(() (values))] 303))
(check === 112
  (let [(dummy -1), (x 1)]
    (let_values [((x y) (values 10 x)),
                 ((z p) (values x 100))]
      (+ x y z p))))


// Duplicate bound names
(expect_syntax_exn
  (let_values [((x) 1), ((x) 2)] 3))
(expect_syntax_exn
  (let_values [((x x) (values 1 2))] 3))

// Result arity mismatch
(expect_result_exn
  (let_values [(() 1)] 3))
(expect_result_exn
  (let_values [((x) (values))] 3))
(expect_result_exn
  (let_values [((x) (values 1 2 3))] 3))
(expect_result_exn
  (let_values [((x y) (values 1))] 3))
(expect_result_exn
  (let_values [((x y) (values 1 2 3))] 3))
(expect_result_exn
  (let_values [((x) 1), ((y z) (values 1 2 3))] 3))


//==========================================================================
// letrec

(check = 1 (letrec [] 1))

(check ident UNDEF
  (letrec [(a b), (c 3), (b a)] a))


// Duplicate bound names
(expect_syntax_exn
  (letrec [(x 1), (b 2), (x 3)] true))


//==========================================================================
// lets

(check === 225 (lets [] 225))
(check === 226 (lets [(x 226)] x))

(check === (+ 19 222)
  (let [(x 5)]
    (lets [(x 19), (y (+ x 222))] y)))

(check === (+ 19 222)
  (lets [(x 19), (y (+ x 222))] y))


//==========================================================================
// is_undef
//   ... tested here because undef should only come out of letrec

(define (is_undef v)
  (ident UNDEF v))

(check_true  (is_undef UNDEF))
(check_false (is_undef (void)))
(check_false (is_undef null))
(check_false (is_undef true))
(check_false (is_undef false))
(check_false (is_undef 0))
(check_false (is_undef ""))

