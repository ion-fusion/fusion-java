// Copyright (c) 2012-2014 Amazon.com, Inc.  All rights reserved.

(require
  "/check"
  "/fusion/experimental/equality")


(define rester
  (lambda rest
    (assert (is_sexp rest))
    rest))

(check === (rester)       (sexp))
(check === (rester 1)     (sexp 1))
(check === (rester 1 2 3) (sexp 1 2 3))

(check === (apply rester [])         (sexp))
(check === (apply rester [1])        (sexp 1))
(check === (apply rester 1 2 [3, 4]) (sexp 1 2 3 4))


// Duplicate bound names
(check_compile_exn
  (lambda (x x) true))
(check_compile_exn
  (lambda (x a b c x) true))


// These expressions crashed due to FUSION-273:
((lambda (t) ((lambda () t))) 1)
(let [(t 1)] ((lambda () t)))
(let [(t 1)] (let_values [] t))


//==========================================================================
// set

(check === ((lambda (x) (set x (+ x 1)) x) 0) 1)

(define counter
  (let ((c 0))
    (lambda ()
      (set c (+ 1 c))
      c)))

(check === (counter) 1)
(check === (counter) 2)
(check === (counter) 3)


//==========================================================================
// let

// Duplicate bound names
(check_compile_exn
  (let [(x 1), (b 2), (x 3)] true))


//==========================================================================
// let_values

(check = (let_values [] 1) 1)

(check = (let_values [((x) 1)] x) 1)

(check ===
  (let_values
    [((x) 1),
     ((y) (values 2))]
    (+ x y))
  3)

(check ===
  (let_values
    [((x) 1),
     ((y) 2),
     ((z) 3)]
    (+ x y z))
  6)

(check ===
  // The dummy var ensures that the x vars have different offsets
  (let [(dummy -1), (x 1)]
    (let_values
      [((x) (+ x 2)),
       ((y) (+ x 10))]
      y))
  11)

(check =
  (let_values [(() (values))] 303)
  303)
(check ===
  (let [(dummy -1), (x 1)]
    (let_values [((x y) (values 10 x)),
                 ((z p) (values x 100))]
      (+ x y z p)))
  112)


// Duplicate bound names
(check_compile_exn
  (let_values [((x) 1), ((x) 2)] 3))
(check_compile_exn
  (let_values [((x x) (values 1 2))] 3))

// Arity mismatch
(check_contract_exn
  (let_values [(() 1)] 3))
(check_contract_exn
  (let_values [((x) (values))] 3))
(check_contract_exn
  (let_values [((x) (values 1 2 3))] 3))
(check_contract_exn
  (let_values [((x y) (values 1))] 3))
(check_contract_exn
  (let_values [((x y) (values 1 2 3))] 3))
(check_contract_exn
  (let_values [((x) 1), ((y z) (values 1 2 3))] 3))


//==========================================================================
// letrec

(check = (letrec [] 1) 1)

(check ident UNDEF
  (letrec [(a b), (c 3), (b a)] a))


// Duplicate bound names
(check_compile_exn
  (letrec [(x 1), (b 2), (x 3)] true))


//==========================================================================
// lets

(check = (lets [] 225) 225)
(check = (lets [(x 226)] x) 226)

(check ===
  (let [(x 5)]
    (lets [(x 19), (y (+ x 222))] y))
  (+ 19 222))

(check ===
  (lets [(x 19), (y (+ x 222))] y)
  (+ 19 222))


//==========================================================================
// is_undef
//   ... tested here because undef should only come out of letrec

(define (is_undef v)
  (ident UNDEF v))

(check_true  (is_undef UNDEF))
(check_false (is_undef (void)))
(check_false (is_undef null))
(check_false (is_undef true))
(check_false (is_undef false))
(check_false (is_undef 0))
(check_false (is_undef ""))

