// Copyright (c) 2012-2014 Amazon.com, Inc.  All rights reserved.

(require
  "/fusion/experimental/check"
  "/fusion/list"
  "/fusion/sequence"
  "/testutils")


//==========================================================================
// is_sequence

(check_true (is_sequence null.list))
(check_true (is_sequence []))
(check_true (is_sequence [1]))
(check_true (is_sequence NULL_SEXP))
(check_true (is_sequence EMPTY_SEXP))
(check_true (is_sequence (sexp 1)))
(check_false (is_sequence {}))
(check_false (is_sequence null.null))
(check_false (is_sequence 1))
(check_false (is_sequence "asdf"))
(check_false (is_sequence (quote 'asdf')))
(check_false (is_sequence 1d-1))
(check_false (is_sequence 1e-1))
(check_false (is_sequence 1970-01-01))

//==========================================================================
// subseq

(define_check (check_subseq orig from to expect)
  (check === expect (subseq orig from to))
  (let [(s (subseq (apply mutable_list orig) from to))]
    (check === expect s)
    (check_pred is_mutable_list s))
  (let [(s (subseq (apply stretchy_list orig) from to))]
    (check === expect s)
    (check_pred is_stretchy_list s))
  (check === (apply sexp expect)
    (subseq (apply sexp orig) from to)))


(check_subseq []      0 0 [])
(check_subseq [1]     0 0 [])
(check_subseq [1]     0 1 [1])
(check_subseq [1]     1 1 [])
(check_subseq [1,2,3] 0 0 [])
(check_subseq [1,2,3] 0 1 [1])
(check_subseq [1,2,3] 0 3 [1,2,3])
(check_subseq [1,2,3] 1 1 [])
(check_subseq [1,2,3] 1 2 [2])
(check_subseq [1,2,3] 1 3 [2,3])
(check_subseq [1,2,3] 0 3 [1,2,3])
(check_subseq [1,2,3] 3 3 [])

(expect_arity_exn (subseq))
(expect_arity_exn (subseq []))
(expect_arity_exn (subseq [] 0 0 0))
(expect_arity_exn (subseq EMPTY_SEXP))
(expect_arity_exn (subseq EMPTY_SEXP 0 0 0))

(expect_argument_exn (subseq 99 0 0))       // 1st arg not a sequence

(expect_argument_exn (subseq null.list 0 0))
(expect_argument_exn (subseq NULL_SEXP 0 0))

(expect_argument_exn (subseq [1,2,3] 4 4))  // expects from <= size
(expect_argument_exn (subseq [1,2,3] 1 4))  // expects to <= size
(expect_argument_exn (subseq [1,2,3] 2 1))  // expects from <= to


//==========================================================================
// fold_left

(check ===  0 (fold_left + 0))
(check ===  0 (fold_left + 0 NULL_SEXP))
(check ===  0 (fold_left + 0 EMPTY_SEXP))
(check ===  0 (fold_left + 0 null.list))
(check ===  0 (fold_left + 0 []))
(check === 10 (fold_left + 1 (sexp 2 3 4)))
(check === 10 (fold_left + 1 [2, 3, 4]))
(check === 45 (fold_left + 1 (sexp 2 3) [4, 5] [6, 7] (sexp 8 9)))
(check === 28 (fold_left + 1 (sexp 2 3 4) (sexp 5 6 7 8)))
(check === 28 (fold_left + 1 (sexp 2 3 4 8) (sexp 5 6 7)))
(check === 28 (fold_left + 1 [2, 3, 4] [5, 6, 7, 8]))
(check === 28 (fold_left + 1 [2, 3, 4, 8] [5, 6, 7]))
(check === 28 (fold_left + 1 [2, 3, 4] (sexp 5 6 7 8)))
(check === 28 (fold_left + 1 [2, 3, 4, 8] (sexp 5 6 7)))
(check ===  1 (fold_left + 1 (sexp 2 3) [4, 5] EMPTY_SEXP [6, 7] (sexp 8 9)))
(check ===  1 (fold_left + 1 (sexp 2 3) [4, 5] [] [6, 7] (sexp 8 9)))
(check ===  1 (fold_left + 1 (sexp 2 3) [4, 5] NULL_SEXP [6, 7] (sexp 8 9)))
(check ===  1 (fold_left + 1 (sexp 2 3) [4, 5] null.list [6, 7] (sexp 8 9)))
(let [(v (stretchy_list))]
  (check === 28
    (fold_left (lambda (result a b) (add_m v (sexp result a b)) (+ result a b))
      1 (sexp 2 3 4) [5, 6, 7, 8]))
  // Check visit order
  (check === [(sexp 1 2 5), (sexp 8 3 6), (sexp 17 4 7)] v))
(check === (sexp 5 4 3 2 1)
  (fold_left (lambda (accum e) (pair e accum)) EMPTY_SEXP (sexp 1 2 3 4 5))
  "fold_left reverse sexp")
(check === {a:1,b:2,c:3}
  (fold_left
    (lambda (accum s) (struct_merge accum s))
    {}
    [{a:1}, {b:2}, {c:3}]))

(expect_arity_exn (fold_left +))
(expect_argument_exn (fold_left + 0 {}))
(expect_argument_exn (fold_left + 0 (sexp 2 3 4) {}))
(expect_argument_exn (fold_left + 0 {} (sexp 2 3 4)))
(expect_argument_exn (fold_left {} 0))
