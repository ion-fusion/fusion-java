// Copyright (c) 2012-2014 Amazon.com, Inc.  All rights reserved.

(require
  "/check"
  "/fusion/list"
  "/fusion/sequence")


//==========================================================================
// is_sequence

(check_true (is_sequence null.list))
(check_true (is_sequence []))
(check_true (is_sequence [1]))
(check_true (is_sequence NULL_SEXP))
(check_true (is_sequence EMPTY_SEXP))
(check_true (is_sequence (sexp 1)))
(check_false (is_sequence {}))
(check_false (is_sequence null.null))
(check_false (is_sequence 1))
(check_false (is_sequence "asdf"))
(check_false (is_sequence (quote 'asdf')))
(check_false (is_sequence 1d-1))
(check_false (is_sequence 1e-1))
(check_false (is_sequence 1970-01-01))

//==========================================================================
// subseq

(define_check (check_subseq msg orig from to expect)
  (check === (subseq orig from to) expect)
  (let [(s (subseq (apply mutable_list orig) from to))]
    (check === s expect)
    (check_pred is_mutable_list s))
  (let [(s (subseq (apply stretchy_list orig) from to))]
    (check === s expect)
    (check_pred is_stretchy_list s))
  (check === (subseq (apply sexp orig) from to) (apply sexp expect)))


(check_subseq []      0 0 [])
(check_subseq [1]     0 0 [])
(check_subseq [1]     0 1 [1])
(check_subseq [1]     1 1 [])
(check_subseq [1,2,3] 0 0 [])
(check_subseq [1,2,3] 0 1 [1])
(check_subseq [1,2,3] 0 3 [1,2,3])
(check_subseq [1,2,3] 1 1 [])
(check_subseq [1,2,3] 1 2 [2])
(check_subseq [1,2,3] 1 3 [2,3])
(check_subseq [1,2,3] 0 3 [1,2,3])
(check_subseq [1,2,3] 3 3 [])

(check_arity_exn (subseq))
(check_arity_exn (subseq []))
(check_arity_exn (subseq [] 0 0 0))
(check_arity_exn (subseq EMPTY_SEXP))
(check_arity_exn (subseq EMPTY_SEXP 0 0 0))

(check_arg_exn (subseq 99 0 0))       // 1st arg not a sequence

(check_arg_exn (subseq null.list 0 0))
(check_arg_exn (subseq NULL_SEXP 0 0))

(check_arg_exn (subseq [1,2,3] 4 4))  // expects from <= size
(check_arg_exn (subseq [1,2,3] 1 4))  // expects to <= size
(check_arg_exn (subseq [1,2,3] 2 1))  // expects from <= to


//==========================================================================
// fold_left

(check === (fold_left + 0) 0)
(check === (fold_left + 0 NULL_SEXP) 0)
(check === (fold_left + 0 EMPTY_SEXP) 0)
(check === (fold_left + 0 null.list) 0)
(check === (fold_left + 0 []) 0)
(check === (fold_left + 1 (sexp 2 3 4)) 10)
(check === (fold_left + 1 [2, 3, 4]) 10)
(check === (fold_left + 1 (sexp 2 3) [4, 5] [6, 7] (sexp 8 9)) 45)
(check === (fold_left + 1 (sexp 2 3 4) (sexp 5 6 7 8)) 28)
(check === (fold_left + 1 (sexp 2 3 4 8) (sexp 5 6 7)) 28)
(check === (fold_left + 1 [2, 3, 4] [5, 6, 7, 8]) 28)
(check === (fold_left + 1 [2, 3, 4, 8] [5, 6, 7]) 28)
(check === (fold_left + 1 [2, 3, 4] (sexp 5 6 7 8)) 28)
(check === (fold_left + 1 [2, 3, 4, 8] (sexp 5 6 7)) 28)
(check === (fold_left + 1 (sexp 2 3) [4, 5] EMPTY_SEXP [6, 7] (sexp 8 9)) 1)
(check === (fold_left + 1 (sexp 2 3) [4, 5] [] [6, 7] (sexp 8 9)) 1)
(check === (fold_left + 1 (sexp 2 3) [4, 5] NULL_SEXP [6, 7] (sexp 8 9)) 1)
(check === (fold_left + 1 (sexp 2 3) [4, 5] null.list [6, 7] (sexp 8 9)) 1)
(let [(v (stretchy_list))]
  (check ===
    (fold_left (lambda (result a b) (add_m v (sexp result a b)) (+ result a b))
      1 (sexp 2 3 4) [5, 6, 7, 8])
    28)
  // Check visit order
  (check === v [(sexp 1 2 5), (sexp 8 3 6), (sexp 17 4 7)]))
(check ===
  (fold_left (lambda (accum e) (pair e accum)) EMPTY_SEXP (sexp 1 2 3 4 5))
  (sexp 5 4 3 2 1)
  "fold_left reverse sexp")
(check ===
  (fold_left
    (lambda (accum s) (struct_merge accum s))
    {}
    [{a:1}, {b:2}, {c:3}])
  {a:1,b:2,c:3})
(check_arity_exn (fold_left +))
(check_arg_exn (fold_left + 0 {}))
(check_arg_exn (fold_left + 0 (sexp 2 3 4) {}))
(check_arg_exn (fold_left + 0 {} (sexp 2 3 4)))
(check_arg_exn (fold_left {} 0))
