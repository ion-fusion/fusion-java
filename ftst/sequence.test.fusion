// Copyright (c) 2012-2014 Amazon.com, Inc.  All rights reserved.

(require
  "/check"
  "/fusion/experimental/equality"
  "/fusion/list"
  "/fusion/sequence")


//==========================================================================
// is_sequence

(check_true (is_sequence null.list))
(check_true (is_sequence []))
(check_true (is_sequence [1]))
(check_true (is_sequence NULL_SEXP))
(check_true (is_sequence EMPTY_SEXP))
(check_true (is_sequence (sexp 1)))
(check_false (is_sequence {}))
(check_false (is_sequence null.null))
(check_false (is_sequence 1))
(check_false (is_sequence "asdf"))
(check_false (is_sequence (quote 'asdf')))
(check_false (is_sequence 1d-1))
(check_false (is_sequence 1e-1))
(check_false (is_sequence 1970-01-01))

//==========================================================================
// fold_left

(check === (fold_left + 0) 0)
(check === (fold_left + 0 NULL_SEXP) 0)
(check === (fold_left + 0 EMPTY_SEXP) 0)
(check === (fold_left + 0 null.list) 0)
(check === (fold_left + 0 []) 0)
(check === (fold_left + 1 (sexp 2 3 4)) 10)
(check === (fold_left + 1 [2, 3, 4]) 10)
(check === (fold_left + 1 (sexp 2 3) [4, 5] [6, 7] (sexp 8 9)) 45)
(check === (fold_left + 1 (sexp 2 3 4) (sexp 5 6 7 8)) 28)
(check === (fold_left + 1 (sexp 2 3 4 8) (sexp 5 6 7)) 28)
(check === (fold_left + 1 [2, 3, 4] [5, 6, 7, 8]) 28)
(check === (fold_left + 1 [2, 3, 4, 8] [5, 6, 7]) 28)
(check === (fold_left + 1 [2, 3, 4] (sexp 5 6 7 8)) 28)
(check === (fold_left + 1 [2, 3, 4, 8] (sexp 5 6 7)) 28)
(check === (fold_left + 1 (sexp 2 3) [4, 5] EMPTY_SEXP [6, 7] (sexp 8 9)) 1)
(check === (fold_left + 1 (sexp 2 3) [4, 5] [] [6, 7] (sexp 8 9)) 1)
(check === (fold_left + 1 (sexp 2 3) [4, 5] NULL_SEXP [6, 7] (sexp 8 9)) 1)
(check === (fold_left + 1 (sexp 2 3) [4, 5] null.list [6, 7] (sexp 8 9)) 1)
(let [(v (stretchy_list))]
  (check ===
    (fold_left (lambda (result a b) (add_m v (sexp result a b)) (+ result a b))
      1 (sexp 2 3 4) [5, 6, 7, 8])
    28)
  // Check visit order
  (check === v [(sexp 1 2 5), (sexp 8 3 6), (sexp 17 4 7)]))
(check ===
  (fold_left (lambda (accum e) (pair e accum)) EMPTY_SEXP (sexp 1 2 3 4 5))
  (sexp 5 4 3 2 1)
  "fold_left reverse sexp")
(check ===
  (fold_left
    (lambda (accum s) (struct_merge accum s))
    {}
    [{a:1}, {b:2}, {c:3}])
  {a:1,b:2,c:3})
(check_arity_exn (fold_left +))
(check_arg_exn (fold_left + 0 {}))
(check_arg_exn (fold_left + 0 (sexp 2 3 4) {}))
(check_arg_exn (fold_left + 0 {} (sexp 2 3 4)))
(check_arg_exn (fold_left {} 0))
