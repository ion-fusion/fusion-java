// Copyright (c) 2012-2014 Amazon.com, Inc.  All rights reserved.

(module procedure "/fusion/private/builtins"

  // WARNING: Doc syntax isn't supported yet.
  '''
Operators for creating and manipulating procedures.
  '''

  (require
    "/fusion/exception"
    "/fusion/experimental/defines"
    "/fusion/experimental/syntax"
    "/fusion/private/compare"
    "/fusion/private/control"
    "/fusion/private/sexp")


  (provide apply is_procedure lambda)


  (defpub identity
    (lambda (v)
      '''
Returns `v`.
      '''
      v))


  (defpub always
    (lambda (v)
      '''
Returns a procedure that accepts (and ignores) any number of arguments and
always returns `v`.
      '''
      (lambda rest v)))


  (defpub_syntax thunk
    '''
    (thunk body ...+)

Returns a zero-argument procedure that evaluates the `body` forms.
    '''
    (lambda (stx)
      (if (= 1 (syntax_size stx))
        (wrong_syntax stx "Expected at least one body form")
        (let [(body (syntax_subseq stx 1))]
          (syntax_append
            (quote_syntax (lambda ()))
            body)))))


  (defpub compose
    (lambda (p1 p2)
      '''
Returns a procedure that first applies `p2` to its (single) argument, and then
applies `p1` to the (single) result.
      '''
      (lambda (x)
        (p1 (p2 x)))))

  //==========================================================================

  // Name comes from Dylan.
  (defpub conjoin
   (lambda (p1 p2)
     '''
Returns a single-argument predicate that is the conjunction of the
single-argument predicates `p1` and `p2` as with `and`, applying them left to
right until one returns an untruthy value.

In other words, the result is similar to using `and` to compose calls to the
predicates.
      '''
      (lambda (x)
        (and (p1 x) (p2 x)))))

  //==========================================================================

  // Name comes from Dylan.
  (defpub disjoin
   (lambda (p1 p2)
      '''
Returns a single-argument predicate that is the disjunction of the
single-argument predicates `p1` and `p2` as with `or`, applying them left to
right until one returns a truthy value.

In other words, the result is similar to using `or` to compose calls to the
predicates.
      '''
      (lambda (x)
        (or (p1 x) (p2 x)))))

  //==========================================================================

  // Name comes from Racket; Dylan calls this `complement`.
  (defpub negate
   (lambda (p)
      '''
Returns a single-argument procedure that applies `not` to the result of the
single-argument procedure `p`.
      '''
      (lambda (x)
        (not (p x)))))

  //==========================================================================

  (defpub curry_left
    '''
    (curry_left proc arg ...+)

Returns a prodedure based on `proc` and the given leftmost `arg`s.

    (define prepend56
      (curry_left append_m [5, 6]))
    (prepend56)                           --> [5,6]
    (prepend56 [1])                       --> [5,6,1]

    (define prepend567
      (curry_left append_m [5, 6] [7]))
    (prepend567 [1] [2,3])                --> [5,6,7,1,2,3]
    '''
    (lambda rest
      (let [(size_rest (size rest))]
        (when (< size_rest 2)
          (apply raise_arity_error "curry_left" 2 rest))
        (let [(proc (head rest)),
              (left_args (tail rest))]
          (unless (is_procedure (head rest))
            (apply raise_argument_error "curry_left" "procedure" 0 rest))
          (if (= size_rest 2)
            // Only one argument, so we can optimize the apply call.
            (let [(left_arg (head left_args))]
              (lambda args
                (apply proc left_arg args)))
            (lambda args
              (apply proc (sexp_append left_args args))))))))


  //==========================================================================

  (defpub curry_right
    '''
    (curry_right proc arg ...+)

Returns a prodedure based on `proc` and the given rightmost `arg`s.

    (define append56
      (curry_right append_m [5, 6]))
    (append56)                             --> [5,6]
    (append56 [1])                         --> [1,5,6]

    (define append567
      (curry_right append_m [5, 6] [7]))
    (append567 [1] [2,3])                  --> [1,2,3,5,6,7]
    '''
    (lambda rest
      (let [(size_rest (size rest))]
        (when (< size_rest 2)
          (apply raise_arity_error "curry_right" 2 rest))
        (let [(proc (head rest)),
              (right_args (tail rest))]
          (unless (is_procedure (head rest))
            (apply raise_argument_error "curry_right" "procedure" 0 rest))
          (lambda args
            (apply proc (sexp_append args right_args)))))))

) // end module
