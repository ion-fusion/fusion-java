// Copyright (c) 2013-2014 Amazon.com, Inc.  All rights reserved.

(module for '/fusion/private/kernel'

  '''
Generic collection "comprehension" forms.
  '''


  (require "/fusion/base"
           "/fusion/experimental/defines"
           "/fusion/experimental/syntax"
           "/fusion/list"
           "/fusion/sexp"
           "/fusion/unsafe/sexp")

  (defpub_j_syntax for_list "com.amazon.fusion.ForListForm")


  (define ctx  // PRIVATE!
    "Lexical context for expanded macros."
    (quote_syntax context))


  (defpub_syntax fors_list
    '''
    (fors_list [(ident series), ...] body ...+)

Like `for_list`, but the `series` are iterated in nested loops instead of in parallel.
Each binding is made available to the following `series` as well as the `body` allowing
for list comprehension.

    (fors_list [(a [1,2]),
                (b [5,7])]
      (* a b))                             => [5, 7, 10, 14]

    (define data [{a:[ {b:1}, {b:2} ]},
                  {a:[ {b:3}, {b:4} ]} ])
    (fors_list [(x data),
                (y (. x "a"))]
      (. y "b"))                           => [1, 2, 3, 4]

    (define data [[[1],[2]],[[3],[4]]])
    (fors_list [(x data),
                (y x),
                (z y)]
      z)                                   => [1, 2, 3, 4]
    '''
    (lambda (stx)
      (let [(content (unsafe_pair_tail (syntax_unwrap stx)))]
        (when (< (size content) 2)
          (wrong_syntax stx "expecting bindings and body"))
        (let [(bindings (syntax_unwrap (unsafe_pair_head content))),
              (body (unsafe_pair_tail content))]
          (unless (and (is_sequence bindings) (not (is_null bindings)))
            (wrong_syntax stx "bindings must be a non-null sequence"))
          (if (== 0 (size bindings))
            /* Base case -- no bindings */
            (datum_to_syntax
              (pair (quote_syntax for_list)   // (for_list
                    (pair []                  //    []
                          body))              //    BODY...)
              ctx
              stx)
            (let [(binding (syntax_unwrap (element bindings 0))),
                  (others  (subseq bindings 1 (size bindings)))]
              (when (or (not (is_sequence binding))
                        (not (= 2 (size binding))))
                (wrong_syntax stx "expecting 2 forms in in each binding pair"))
              (if (== 0 (size others))
                /* Base case -- single binding */
                (datum_to_syntax
                  (pair (quote_syntax for_list)   // (for_list
                        (pair bindings            //    BINDINGS
                              body))              //    BODY...)
                  ctx
                  stx)
                /* Recursive case */
                (datum_to_syntax
                  (sexp (quote_syntax apply)         // (apply
                    (quote_syntax append_m)          //   append_m
                    []                               //   []
                    (sexp (quote_syntax for_list)    //   (for_list
                      (sexp (element bindings 0))    //     (BINDING)
                      (pair (quote_syntax fors_list) //     (fors_list
                        (pair others                 //       (OTHERS...)
                              body))))               //       BODY...)))
                  ctx
                  stx))))))))
)
