// Copyright (c) 2012-2017 Amazon.com, Inc.  All rights reserved.

/*                       *** WARNING ***
 *
 * There may be customer dependencies on this module!  See FUSION-184
 */


(module syntax '/fusion/private/kernel'

  '''
Experimental operators for macros and syntax manipulation.

<!-- FUSION-185 This comment forces FusionDoc to stop the one-liner here. -->

## WARNING

This module contains unstable, experimental features.
There is **NO SUPPORT** for this module.

## Overview

Fusion’s macro system is intended to be operationally identical to that of
Racket, so we strongly recommend taking advantage of the extensive
documentation Racket provides.

Fusion does not yet implement Racket's higher-level macro facilities like
`define-syntax-rule` so one has to work with more primitive tools.

Fusion’s current feature-set generally aligns with the content of these parts
of the [Racket Guide](http://docs.racket-lang.org/guide/index.html):

  * [Lexical Scope](http://docs.racket-lang.org/guide/pattern-macros.html#%28part._.Lexical_.Scope%29)
  * [Macro Transformer Procedures](http://docs.racket-lang.org/guide/macro-transformers.html)
  * [Syntax Objects](http://docs.racket-lang.org/guide/stx-obj.html)

To write low-level macros you'll want to be familiar with these parts of the
[Racket Reference](http://docs.racket-lang.org/reference/index.html):

  * [Syntax Model](http://docs.racket-lang.org/reference/syntax-model.html)
  * [Syntax Objects](http://docs.racket-lang.org/reference/stxops.html),
    especially `datum->syntax` and `syntax-e` (which Fusion calls `syntax_unwrap`).
  * [Syntax Quoting](http://docs.racket-lang.org/reference/Syntax_Quoting__quote-syntax.html)
  * [Expanding_Top-Level_Forms](http://docs.racket-lang.org/reference/Expanding_Top-Level_Forms.html)

## Limitations

Here’s some notable things missing from Fusion’s current macro system compared
to Racket:

  * There’s only one [expansion phase](http://docs.racket-lang.org/reference/syntax-model.html#%28part._mod-parse%29),
    which primarily means one must generally import a macro from another module
    before using it.
  * Not all [expansion contexts](http://docs.racket-lang.org/reference/syntax-model.html#%28part._expand-context-model%29)
    are implemented. There’s no internal definitions yet; see [FUSION-36](issue:FUSION-36).
  * Tamper status (aka [tainting](http://docs.racket-lang.org/reference/stxcerts.html))
    is not implemented.

These are the primary reasons this module is “experimental”. Of particular
concerned is that extant code may break when phases are introduced.

## Internals

Fusion implements the lexical-context algorithms used by Racket 6.2 and earlier,
which is best described by Matthew Flatt's paper,
[_Composable and Compilable Macros_](https://www.cs.utah.edu/plt/publications/macromod.pdf).

Racket 6.3 introduced a new mechanism for tracking lexical context. Quoting the
[Racket Blog](http://blog.racket-lang.org/2015/11/racket-v63.html):

> Racket’s macro expander uses a new representation of binding called “set of
> scopes”. The new binding model provides a simpler explanation of how macros
> preserve binding, especially across module boundaries and in hygiene-bending
> expansions. The new expander is mostly compatible with existing Racket
> macros, but there are some incompatibilities. For the formally inclined, a
> research paper on this macro system will appear at POPL next year:
> http://www.cs.utah.edu/plt/scope-sets/

We intend for Fusion to migrate to this algorithm, too, since it is
significantly simpler to implement and easier to understand.
  '''


  // This is split into two files because the compiler requires that built-in
  // syntactic forms must be imported from another module.
  // That's true everywhere except for these low-level modules.

  (require
    "/fusion/private/kernel2"
    "/fusion/private/metasyntax"
  )

  (provide datum_to_syntax define_syntax expand_once free_identifier_equal
    is_identifier is_syntax
    quasisyntax quote_syntax
    syntax_append syntax_column syntax_cons_q syntax_get syntax_line
    syntax_property syntax_size syntax_subseq
    syntax_to_datum syntax_track_origin syntax_unwrap unsyntax wrong_syntax)


  (define datum_to_syntax (java_new "com.amazon.fusion.DatumToSyntaxProc"))

  (define expand_once
    '''
    (expand_once top_level_form)

Expands a top-level form through one step of macro expansion, using the
bindings of the current namespace.

The `top_level_form` may be a syntax object or another datum.
    '''
    (java_new "com.amazon.fusion.FusionEval$ExpandOnceProc"))

  (define is_identifier   (java_new "com.amazon.fusion.FusionSyntax$IsIdentifierProc"))
  (define is_syntax       (java_new "com.amazon.fusion.FusionSyntax$IsSyntaxProc"))
  (define syntax_append   (java_new "com.amazon.fusion.SyntaxAppendProc"))
  (define syntax_column   (java_new "com.amazon.fusion.SyntaxColumnProc"))
  (define syntax_get      (java_new "com.amazon.fusion.SyntaxGetProc"))
  (define syntax_line     (java_new "com.amazon.fusion.SyntaxLineProc"))
  (define syntax_size     (java_new "com.amazon.fusion.SyntaxSizeProc"))
  (define syntax_source   (java_new "com.amazon.fusion.SyntaxSourceProc"))
  (define syntax_subseq   (java_new "com.amazon.fusion.SyntaxSubseqProc"))
  (define syntax_to_datum (java_new "com.amazon.fusion.FusionSyntax$ToDatumProc"))
  (define syntax_unwrap   (java_new "com.amazon.fusion.FusionSyntax$UnwrapProc"))

  (define free_identifier_equal (java_new "com.amazon.fusion.FreeIdentifierEqualProc"))

  (define syntax_property
    (java_new "com.amazon.fusion.FusionSyntax$PropertyProc"))


  (provide syntax_track_origin)
  (define syntax_track_origin
    '''
    (syntax_track_origin new_stx orig_stx origin)

Copies properties from `orig_stx` to `new_stx` and extending origin data with
the `origin` identifier.
    '''
    (java_new "com.amazon.fusion.FusionSyntax$TrackOriginProc"))


  // TODO Should probably remove; it's unnecessary.  Racket doesn't have it.
  (provide syntax_origin)
  (define (syntax_origin stx)
    "DEPRECATED as of FusionJava R23"
    (syntax_property stx (quote origin)))


  (provide syntax_is_original)
  (define syntax_is_original
    (java_new "com.amazon.fusion.FusionSyntax$IsOriginalProc"))


  // '_q' suffix intended to denote that the car is quoted by the syntax form.
  // Otherwise this would be a procedure.
  (define_syntax syntax_cons_q
    (lambda (stx)
      (quasisyntax
        (syntax_append (quote_syntax ((unsyntax (syntax_get stx 1))))
                       (unsyntax (syntax_get stx 2))))))
)
