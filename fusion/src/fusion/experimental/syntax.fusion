// Copyright (c) 2012-2020 Amazon.com, Inc.  All rights reserved.

/*                       *** WARNING ***
 *
 * There may be customer dependencies on this module!  See FUSION-184
 */


(module syntax '/fusion/private/kernel'

  '''
Experimental operators for macros and syntax manipulation.

<!-- FUSION-185 This comment forces FusionDoc to stop the one-liner here. -->

## WARNING

This module contains unstable, experimental features.
There is **NO SUPPORT** for this module.

## Overview

Fusion’s macro system is intended to be operationally identical to that of
Racket, so we strongly recommend taking advantage of the extensive
documentation Racket provides.

Fusion does not yet implement Racket's higher-level macro facilities like
`define-syntax-rule` so one has to work with more primitive tools.

Fusion’s current feature-set generally aligns with the content of these parts
of the [Racket Guide](http://docs.racket-lang.org/guide/index.html):

  * [Lexical Scope](http://docs.racket-lang.org/guide/pattern-macros.html#%28part._.Lexical_.Scope%29)
  * [Macro Transformer Procedures](http://docs.racket-lang.org/guide/macro-transformers.html)
  * [Syntax Objects](http://docs.racket-lang.org/guide/stx-obj.html)

To write low-level macros you'll want to be familiar with these parts of the
[Racket Reference](http://docs.racket-lang.org/reference/index.html):

  * [Syntax Model](http://docs.racket-lang.org/reference/syntax-model.html)
  * [Syntax Objects](http://docs.racket-lang.org/reference/stxops.html),
    especially `datum->syntax` and `syntax-e` (which Fusion calls `syntax_unwrap`).
  * [Syntax Quoting](http://docs.racket-lang.org/reference/Syntax_Quoting__quote-syntax.html)
  * [Expanding Top-Level Forms](http://docs.racket-lang.org/reference/Expanding_Top-Level_Forms.html)

## Limitations

Here’s some notable things missing from Fusion’s current macro system compared
to Racket:

  * There’s only one [expansion phase](http://docs.racket-lang.org/reference/syntax-model.html#%28part._mod-parse%29),
    which primarily means one must generally import a macro from another module
    before using it.
  * Not all [expansion contexts](http://docs.racket-lang.org/reference/syntax-model.html#%28part._expand-context-model%29)
    are implemented. There’s no internal definitions yet; see [FUSION-36](issue:FUSION-36).
  * Tamper status (aka [tainting](http://docs.racket-lang.org/reference/stxcerts.html))
    is not implemented.

These are the primary reasons this module is “experimental”. Of particular
concern is that extant code may break when phases are introduced.

## Internals

Fusion implements the lexical-context algorithms used by Racket 6.2 and earlier,
which is best described by Matthew Flatt's paper,
[_Composable and Compilable Macros_](https://www.cs.utah.edu/plt/publications/macromod.pdf).

Racket 6.3 introduced a new mechanism for tracking lexical context. Quoting the
[Racket Blog](http://blog.racket-lang.org/2015/11/racket-v63.html):

> Racket’s macro expander uses a new representation of binding called “set of
> scopes”. The new binding model provides a simpler explanation of how macros
> preserve binding, especially across module boundaries and in hygiene-bending
> expansions. The new expander is mostly compatible with existing Racket
> macros, but there are some incompatibilities. For the formally inclined, a
> research paper on this macro system will appear at POPL next year:
> http://www.cs.utah.edu/plt/scope-sets/

We intend for Fusion to migrate to this algorithm, too, since it is
significantly simpler to implement and easier to understand.
  '''


  // This is split into two files because the compiler requires that built-in
  // syntactic forms must be imported from another module.
  // That's true everywhere except for these low-level modules.

  (require
    "/fusion/private/kernel2"
    "/fusion/private/metasyntax"
    "/fusion/private/raise"
    "/fusion/private/sexp"
    "/fusion/void"
  )

  (provide
    bound_identifier_equal
    check_duplicate_identifier
    datum_to_syntax
    define_syntax
    expand_once
    free_identifier_equal
    is_identifier
    is_syntax
    quasisyntax
    quote_syntax
    syntax_append
    syntax_column
    syntax_cons_q
    syntax_get
    syntax_is_original
    syntax_line
    syntax_origin
    syntax_property
    syntax_size
    syntax_subseq
    syntax_to_datum
    syntax_track_origin
    syntax_unwrap
    unsyntax
    wrong_syntax)


  (define datum_to_syntax
    '''
    (datum_to_syntax datum [context location])

Recursively converts the `datum` to a syntax object with lexical information
copied from the `context` syntax identifier, and source-location copied from
the `location` syntax object. Existing syntax objects in `datum` are included
as-is.

When `context` isn't provided, converted syntax objects have no lexical
context.  When `location` isn't provided, they will have no location.
    '''
    (java_new "com.amazon.fusion.DatumToSyntaxProc"))


  (define expand_once
    '''
    (expand_once top_level_form)

Expands a top-level form through one step of macro expansion, using the
bindings of the current namespace.

The `top_level_form` may be a syntax object or another datum.
    '''
    (java_new "com.amazon.fusion.FusionEval$ExpandOnceProc"))


  (define is_identifier
    '''
    (is_identifier value)

Determines whether a `value` is a syntax object holding a symbol, returning
`true` or `false`.
    '''
    (java_new "com.amazon.fusion.FusionSyntax$IsIdentifierProc"))


  (define is_syntax
    '''
    (is_syntax value)

Determines whether a `value` is a syntax object, returning `true` or `false`.
    '''
    (java_new "com.amazon.fusion.FusionSyntax$IsSyntaxProc"))


  (define syntax_append
    '''
    (syntax_append front back ...)

Returns a new syntax sexp that combines the `front` and `back` syntax
sequences.
    '''
    (java_new "com.amazon.fusion.SyntaxAppendProc"))


  (define syntax_column
    '''
    (syntax_column stx)

Returns the one-based column number of the source of a syntax object.
The result is zero if there's no column number available.
    '''
    (java_new "com.amazon.fusion.SyntaxColumnProc"))


  (define syntax_get
    '''
    (syntax_get container key ...)

Traverses down through syntax objects.
`container` must be syntax container (struct, list, or sexp).
Each `key` must be a string, symbol, or int, to denote either a struct's
field-name or a sequence's index.
    '''
    (java_new "com.amazon.fusion.SyntaxGetProc"))


  (define syntax_line
    '''
    (syntax_line stx)

Returns the one-based line number of the source of a syntax object.
The result is zero if there's no line number available.
    '''
    (java_new "com.amazon.fusion.SyntaxLineProc"))


  (define syntax_size
    '''
    (syntax_size sequence)

Returns the number of child elements contained in the syntax sequence.
The size of `null.list` and `null.sexp` is zero.
    '''
    (java_new "com.amazon.fusion.SyntaxSizeProc"))


  (define syntax_source
    '''
    (syntax_source stx)

Returns a description of the source of a syntax object.
    '''
    (java_new "com.amazon.fusion.SyntaxSourceProc"))


  (define syntax_subseq
    '''
    (syntax_subseq sequence from)

Returns a new syntax sexp that copies children from `sequence` starting at
`from`.  If `from` is beyond the end of the sequence, the result is an empty
sequence.
    '''
    (java_new "com.amazon.fusion.SyntaxSubseqProc"))


  (define syntax_to_datum
    '''
    (syntax_to_datum syntax)

Given a `syntax` object, removes the lexical information and returns a plain
value, unwrapping all layers recursively.
    '''
    (java_new "com.amazon.fusion.FusionSyntax$ToDatumProc"))


  (define syntax_unwrap
    '''
    (syntax_unwrap syntax)

Given a `syntax` object, removes the lexical information and returns a plain
value. This only unwraps one layer, retaining inner syntax objects.
    '''
    (java_new "com.amazon.fusion.FusionSyntax$UnwrapProc"))


  (define bound_identifier_equal
    '''
    (bound_identifier_equal id1 id2)

Compares two identifiers to determine whether `id1` would bind `id2`
(or vice versa) if one were in a binding position and the other in a suitable
reference position.
    '''
    (java_new "com.amazon.fusion.SyntaxSymbol$BoundIdentifierEqualProc"))


  (define free_identifier_equal
    '''
    (free_identifier_equal identifier1 identifier2)

Compares two identifiers to determine whether they both refer to the same
binding.
    '''
    (java_new "com.amazon.fusion.SyntaxSymbol$FreeIdentifierEqualProc"))


  (define syntax_property
    (java_new "com.amazon.fusion.FusionSyntax$PropertyProc"))


  (define syntax_track_origin
    '''
    (syntax_track_origin new_stx orig_stx origin)

Copies properties from `orig_stx` to `new_stx` and extending origin data with
the `origin` identifier.
    '''
    (java_new "com.amazon.fusion.FusionSyntax$TrackOriginProc"))


  // TODO Should probably remove; it's unnecessary.  Racket doesn't have it.
  (define (syntax_origin stx)
    "DEPRECATED as of FusionJava R23"
    (syntax_property stx (quote origin)))


  (define syntax_is_original
    (java_new "com.amazon.fusion.FusionSyntax$IsOriginalProc"))


  // '_q' suffix intended to denote that the car is quoted by the syntax form.
  // Otherwise this would be a procedure.
  (define_syntax syntax_cons_q
    (lambda (stx)
      (quasisyntax
        (syntax_append (quote_syntax ((unsyntax (syntax_get stx 1))))
                       (unsyntax (syntax_get stx 2))))))


  (define (check_duplicate_identifier ids)
    '''
Given a sexp of identifiers `ids`, compares each pair of identifiers with
`bound_identifier_equal`.  If any comparison returns `true`, the result is the
first duplicate identifier (_i.e._, the first with a preceding match);
otherwise the result is void.
    '''
    // TODO Improve performance: this is O(n²). Should use a bound-id-set.
    //   This is okay for now since most local binding environments are small.
    (letrec [(is_sexp_of_ids
               (lambda (ids)
                 (if (is_sexp ids)
                   (if (is_pair ids)
                     (if (is_identifier (head ids))
                       (is_sexp_of_ids (tail ids))
                       false)
                     true)
                   false))),
             (has_duplicate_identifier
               (lambda (id ids)
                 "Is `id` `bound_identifier_equal` to any element of `ids`?"
                 (if (is_pair ids)
                   (if (bound_identifier_equal id (head ids))
                     true
                     (has_duplicate_identifier id (tail ids)))
                   false))),
             (find_dupe
               (lambda (no_dupes ids)
                 (if (is_pair ids)
                   (let_values [((id) (head ids))]
                     (if (has_duplicate_identifier id no_dupes)
                       id
                       (find_dupe (pair id no_dupes) (tail ids))))
                   (void))))]             // Empty sexp has no duplicates
      (if (is_sexp_of_ids ids)
        (find_dupe (quote ()) ids)
        (raise_argument_error "check_duplicate_identifier" "sexp of identifiers" 0 ids))))
)
