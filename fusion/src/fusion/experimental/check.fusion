// Copyright (c) 2012-2014 Amazon.com, Inc.  All rights reserved.

/*                       *** WARNING ***
 *
 * There are customer dependencies on this module!  See FUSION-333
 */

(module check "/fusion"

  '''
A lightweight unit testing library.

This module allows applications to build a suite of tests in the form of Fusion
scripts, where each script uses this module to express a number of _checks_
that each validate some aspect of the code under test.

For examples of these features in action, peruse
[Fusion's own test suite](code:trees/mainline/--/ftst).

These APIs are inspired by those of
[RackUnit](http://docs.racket-lang.org/rackunit)
by Noel Welsh and Ryan Culpepper.

<!-- FUSION-185 This comment forces FusionDoc to stop the one-liner here. -->

## WARNING

This module contains unstable, experimental features.
There is **NO SUPPORT** for this module.


## Checks

_Checks_ are the fundamental components of test scripts.  A check executes some
logic, and either returns void to express success, or throws
a "check exception" to express failure.
This library provides a range of primitive checks, and applications can
compose them into higher-level checks with broader responsibilites.

In order to present helpful output when failures occur, all checks are
syntactic forms.  Nevertheless, they work like procedures: the arguments are
treated as expressions and evaluated left-to-right.  (They cannot, however, be
used like first-class procedures and passed as runtime values.)


## Expecting Exceptions

The `expect_*_exn` forms verify that certain kinds of exceptions
are raised by some code under test.  Unlike the `check_*` forms, these do not
act like procedures: evaluation of the argument is implicitly delayed via
`thunk` to allow an exception handler to be installed.

For the purposes of these forms, Fusion exceptions can be understood to have
an inheritance hierarchy along these lines:

  * any
      * contract
          * argument
          * arity
          * result
      * syntax
      * check

So, for example, `expect_contract_exn` will succeed whenever `expect_arity_exn`
would succeed.


## Defining New Checks

You can compose your own checks from those given here by using `define_check`.
By doing so, failure reports will include the check name, source code location,
and actual arguments.  The entire active "stack" of checks is reported.

Failure of a check is induced via `fail_check` which raises a check exception
that displays the current stack of check frames.

Here's some examples from the basic checks:

    (define_check (fail)
      (fail_check))

    (define_check (check op val1 val2)
      (unless (op val1 val2)
        (fail_check)))

    (define_check (check_pred pred val)
      (unless (pred val)
        (fail_check)))

    (define_check (check_same expected actual)
      (unless (same expected actual)
        (fail_check)))

For simple cases like these, there's `define_simple_check` and
`define_binary_check`; the latter improves failure reporting by displaying
the expected and actual values.

    (define_simple_check (check_pred pred val)
      (pred val))

    (define_binary_check (check_same expected actual)
      (same expected actual))
  '''


  (require
    "/fusion/eval"
    "/fusion/exception"
    "/fusion/experimental/defines"
    "/fusion/experimental/syntax"
    "/fusion/ffi/java"
    "/fusion/parameter")


  (define check_stack_param
    (make_parameter null))


  (defpub fail_check
    (java_new "com.amazon.fusion.FailCheckProc" check_stack_param))


  // Not public: the signature is awkward.
  (define (_fail_check meta)
    '''
Raises a check failure exception, including a stack trace derived from the
`check_stack_param` marks.
    '''
    (parameterize [(check_stack_param meta)]
      (fail_check)))


  (defpub_syntax define_check
    '''
    (define_check (name arg ...) expr ...)

Defines a new check form that's invoked as:

    (name arg_expr ... [message])

Note that the optional `message` arg is added automatically and is not part of
the declared signature.

The body is typically composed of several other checks, all of which must pass
for the new check to succeed.  The body may not use the new check recursively.
Any results from the body are ignored and the check form always returns void.

For example:

    (define_check (check_comparisons lo hi)
      (check <  lo hi)
      (check <= lo hi)
      (check =  lo lo)
      (check =  hi hi)
      (check >= hi lo)
      (check >  hi lo))
    '''
    (let [(ctx   (quote_syntax here)),
          (wrong (lambda (stx)
                   (wrong_syntax stx
                     '''Bad syntax for define_check; usage: '''
                     '''(define_check (name arg ...) expr ...)''')))]
      (lambda (stx)
        (when (< (syntax_size stx) 3)
          (wrong stx))
        (lets
          [(orig_args (tail (syntax_unwrap stx))),
           (signature (let [(s (syntax_unwrap (head orig_args)))]
                        (if (and (is_sexp s)
                                 (> (size s) 0)
                                 (every is_identifier s))
                            s
                            (wrong stx)))),
           (usage     (string_append "("
                                     (apply string_append
                                       (map (lambda (i)
                                              (string_append
                                                (syntax_unwrap i)
                                                " "))
                                          signature))
                                     "[message])")),
           (docs      (let [(d (syntax_unwrap (element orig_args 1)))]
                        (if (is_string d) d null.string))),
           (body      (if (is_null docs)
                          (tail orig_args)
                          (tail (tail orig_args)))),
           (name_stx  (head signature)),
           // TODO check for duplicate arg names
           (args      (tail signature)),
           (arg_count (size args)),
           (arity_msg (string_append (syntax_unwrap name_stx)
                                     " requires "
                                     (int_to_string arg_count)
                                     " or "
                                     (int_to_string (+ 1 arg_count))
                                     (if (= 1 arg_count) " arg" " args")
                                     "; usage: "
                                     usage)),
           (proc_name (datum_to_syntax
                          (string_to_symbol
                            (string_append "_" (syntax_unwrap name_stx)))
                          // TODO FUSION-329 Should use stx as context.
                          // This isn't always correct since the name could
                          // be coming from elsewhere.
                          name_stx))]
          (datum_to_syntax
            (quasiquote
              (begin
                (define (unquote proc_name)
                  (lambda rest  // (meta ARG ... [message])
                    // Arity checking has happened in the calling check macro.
                    (let [(named_args (subseq rest
                                              1
                                              (unquote (+ 1 arg_count))))]
                      (parameterize
                        [(check_stack_param
                           (struct_merge (head rest)
                             (apply struct
                               "name" (quote (unquote name_stx))
                               "args" named_args
                               (if (> (size rest) (unquote (+ 1 arg_count)))
                                   (sexp "message" (last rest))
                                   (quote ())))))]
                        (apply (lambda (unquote args)
                                 (unquote (pair (quote begin) body)))
                          named_args)
                        // All checks return void.
                        (void)))))
                (define_syntax (unquote name_stx)
                  (unquote (string_append "\n    " usage "\n"
                             (or docs "")))
                  (let [(ctx1 (quote_syntax here1))]
                    (lambda (stx1)
                      (let [(actuals (tail (syntax_unwrap stx1)))]
                        (when (or (< (size actuals) (unquote arg_count))
                                  (> (size actuals) (unquote (+ 1 arg_count))))
                          (wrong_syntax stx1 (unquote arity_msg)))
                        (let [(meta { expression: (syntax_to_datum stx1),
                                      line:       (syntax_line stx1),
                                      column:     (syntax_column stx1) })]
                          (datum_to_syntax
                            (pair (quote_syntax (unquote proc_name))
                                  (pair (sexp (quote quote) meta)
                                        actuals))
                            ctx1
                            stx1))))))))
            ctx
            stx)))))


  (defpub_syntax define_simple_check
    '''
    (define_simple_check (name arg ...) expr ...)

Defines a new check form that's invoked as:

    (name arg_expr ... [message])

Note that the optional `message` arg is added automatically and is not part of
the declared signature.

The new check succeeds if the result of the `expr`s is truthy.
The body may not use the new check recursively.

For example:

    (define_simple_check (check_pred pred val)
      (pred val))
    '''
    (let [(ctx (quote_syntax here)),
          (wrong (lambda (stx)
                   (wrong_syntax stx
                     '''Bad syntax for define_simple_check; usage: '''
                     '''(define_simple_check (name arg ...) expr ...)''')))]
      (lambda (stx)
        (when (< (syntax_size stx) 3)
          (wrong stx))
        (lets
          [(orig_args (tail (syntax_unwrap stx))),
           (signature (let [(s (syntax_unwrap (head orig_args)))]
                        (if (and (is_sexp s)
                                 (> (size s) 0)
                                 (every is_identifier s))
                            s
                            (wrong stx)))),
           (docs      (let [(d (syntax_unwrap (element orig_args 1)))]
                        (if (is_string d) d null.string))),
           (body      (if (is_null docs)
                          (tail orig_args)
                          (tail (tail orig_args))))]
          (datum_to_syntax
            (quasiquote
              (define_check (unquote signature)
                (unquote docs)
                (if (unquote (pair (quote begin) body))
                    (void)
                    (fail_check))))
            ctx
            stx)))))


  (defpub_syntax define_binary_check
    '''
    (define_binary_check (name expected actual) expr ...)

Defines a new check form that's invoked with expected and actual values, and an
optional message.

Like `define_simple_check`, the new check succeeds if the result of the `expr`s
is truthy. However, this form automatically adds the `expected` and `actual`
values to the failure report.

The body may not use the new check recursively.

For example:

    (define_binary_check (check_same expected actual)
      (same expected actual))
    '''
    (let [(ctx (quote_syntax here)),
          (wrong (lambda (stx)
                   (wrong_syntax stx
                     '''Bad syntax for define_binary_check; usage: '''
                     '''(define_binary_check (name expected actual) expr ...)''')))]
      (lambda (stx)
        (when (< (syntax_size stx) 3)
          (wrong stx))
        (lets
          [(orig_args (tail (syntax_unwrap stx))),
           (signature (let [(s (syntax_unwrap (head orig_args)))]
                        (if (and (is_sexp s)
                                 (=== (size s) 3)
                                 (every is_identifier s))
                            s
                            (wrong stx)))),
           (docs      (let [(d (syntax_unwrap (element orig_args 1)))]
                        (if (is_string d) d null.string))),
           (body      (if (is_null docs)
                          (tail orig_args)
                          (tail (tail orig_args))))]
          (datum_to_syntax
            (quasiquote
              (define_check (unquote signature)
                (unquote docs)
                (parameterize
                  [(check_stack_param
                      (struct "expected" (unquote (element signature 1))
                              "actual"   (unquote (element signature 2))))]
                  (if (unquote (pair (quote begin) body))
                      (void)
                      (fail_check)))))
            ctx
            stx)))))


  //===========================================================================

  (provide fail)
  (define_check (fail)
    '''
A check that fails unconditionally.
    '''
    (fail_check))


  (provide check)
  (define_simple_check (check op val1 val2)
    '''
Checks that the result of `(op val1 val2)` is truthy.
    '''
    (op val1 val2))


  (provide check_pred)
  (define_simple_check (check_pred pred val)
    '''
Checks that the result of `(pred val)` is truthy.
    '''
    (pred val))


  (provide check_same)
  (define_binary_check (check_same expected actual)
    '''
Checks that `(same expected actual)` is truthy.
    '''
    (same expected actual))


  (provide check_true)
  (define_check (check_true val)
    '''
Checks that `val` is `true` (as opposed to truthy).
Annotations are ignored.
    '''
    (unless (= true val)
      (_fail_check {actual:val})))


  (provide check_false)
  (define_check (check_false val)
    '''
Checks that `val` is `false` (as opposed to untruthy).
Annotations are ignored.
    '''
    (unless (= false val)
      (_fail_check {actual:val})))


  (provide check_null)
  (define_check (check_null val)
    '''
Checks that `val` is any null.
    '''
    (unless (is_null val)
      (_fail_check {actual:val})))


  (provide check_void)
  (define_check (check_void val)
    '''
Checks that `val` is void.
    '''
    (unless (is_void val)
      (_fail_check {actual:val})))


  (provide check_annotations)
  (define_check (check_annotations expected value)
    '''
Checks that the `value` has the `expected` annotations.  `expected` must be a
sequence of strings or symbols.

For example, these checks succeed:

    (check_annotations [] null)
    (check_annotations ["a"] (quote a::null))
    (check_annotations (quote (a b)) (quote a::b::null))

This one fails because the expected and actual annotations are not in the same
order:

    (check_annotations ["b", "a"] (quote a::b::null))
    '''
    (unless (= expected (annotations value))
      (_fail_check {expected:expected, actual:(annotations value)})))


  //===========================================================================


  (define _check_exn
    (java_new "com.amazon.fusion.CheckExceptionProc"))

  // Currently not a "real" check macro; that adds noise to error reports
  // and exposes our tag strings.
  (define (check_exn tag thunk)
    (let [(e (_check_exn tag thunk))]
      (when (is_string e)
        (if (== "" e)
          (_fail_check { expected: (string_append tag " exception")})
          (_fail_check { expected: (string_append tag " exception"),
                         actual:   e })))))


  // This should really be a procedure, but it doesn't work.
  (define_syntax define_exn_check
    '''
    (define_exn_check name tag)

Defines a exception-expecting form used like `(name EXPR)`.
    '''
    (lambda (stx)
      (lets [(ctx (quote_syntax here)),
             (name_stx (syntax_get stx 1)),
             (tag (syntax_unwrap (syntax_get stx 2))),
             (skip_frame (not (syntax_unwrap (syntax_get stx 3)))),
             (docs (if skip_frame ""
                     (string_append '''
    (''' (syntax_unwrap name_stx) ''' expr [message])

Evaluates `expr` and checks that it throws an exception like that thrown by
''' (syntax_unwrap (syntax_get stx 3)) '''.  If no exception is thrown, or if
another kind of exception is thrown, then the check fails.''')))]
        (datum_to_syntax
          (quasiquote
            (define_syntax (unquote name_stx)  // (name EXPR [message])
              (unquote docs)
              (let [(ctx1 (quote_syntax here1))]
                (lambda (stx1)
                  (lets [(actuals (tail (syntax_unwrap stx1))),
                         (thunk_stx (if (or (is_empty actuals)
                                            (> (size actuals) 2))
                                        (wrong_syntax stx1
                                          (unquote
                                            (string_append
                                              (syntax_unwrap name_stx)
                                              " requires 1 or 2 args; usage: ("
                                              (syntax_unwrap name_stx)
                                              " expr [message])")))
                                        (head actuals))),
                         (meta (unquote
                                 (if skip_frame {}
                                   (quasiquote
                                     (struct "name"       (quote (unquote name_stx))
                                             "expression" (syntax_to_datum stx1)
                                             "line"       (syntax_line stx1)
                                             "column"     (syntax_column stx1))))))]
                    (datum_to_syntax
                        // (parameterize
                        //   [(check_stack_param META)]
                        //   (check_exn TAG (lambda () BODY)))
                      (sexp
                        (quote_syntax parameterize)
                        [(sexp (quote_syntax check_stack_param)
                               (if (== (syntax_size stx1) 2)
                                 (sexp (quote_syntax quote) meta)
                                 (quasisyntax
                                   (struct_merge
                                     (quote (unsyntax (datum_to_syntax meta)))
                                     (struct "message"
                                       (unsyntax (syntax_get stx1 2)))))))]
                        (sexp
                          (quote_syntax check_exn)
                          (unquote tag)
                          (sexp (quote_syntax lambda) (quote ()) thunk_stx)))
                      ctx1
                      stx1))))))
          ctx
          stx))))


  (provide
    expect_any_exn expect_argument_exn expect_arity_exn
    expect_check_exn expect_contract_exn expect_result_exn)

  (define_exn_check expect_any_exn      "any"      "any built-in feature")
  (define_exn_check expect_argument_exn "argument" "`raise_argument_error`")
  (define_exn_check expect_arity_exn    "arity"    "`raise_arity_error`")
  (define_exn_check expect_check_exn    "check"    "`fail_check`")
  (define_exn_check expect_contract_exn "contract" "`raise_contract_error`")
  (define_exn_check expect_result_exn   "result"   "`raise_result_error`")

  // NOT PUBLIC! Only used by the public version below.
  (define_exn_check _expect_syntax_exn  "syntax"   false /*skip frame*/)

  (defpub_syntax expect_syntax_exn
    '''
    (expect_syntax_exn top_form [message])

Passes the given top-level form to `eval` and checks that it throws an
exception like that thrown by `wrong_syntax`.

This form currently doesn't work as expected within a module: the evaluation
context is not the module's namespace, because `current_namespace` isn't
changed when compiling a module's body.  To test for syntax errors in a module,
wrap the module with this form. So don't do this:

    (module test "/fusion"
      (expect_syntax_exn <something>))

but do this instead:

    (expect_syntax_exn
      (module test "/fusion"
        <something>))
    '''
    (lambda (stx)
      (let [(actuals (tail (syntax_unwrap stx)))]
        (when (or (is_empty actuals) (> (size actuals) 2))
          (wrong_syntax stx
            '''expect_syntax_exn requires 1 or 2 args; '''
            '''usage: (expect_syntax_exn top_form [message])'''))
        (let [(top_form (head actuals)),
              (meta (struct "name"       (quote expect_syntax_exn)
                            "expression" (syntax_to_datum stx)
                            "line"       (syntax_line stx)
                            "column"     (syntax_column stx)))]
          (datum_to_syntax
            // (parameterize
            //   [(check_stack_param (quote META))]
            //   (_expect_syntax_exn (eval (quote_syntax TOP)) [MESSAGE]))
            (sexp
              (quote_syntax parameterize)
              [(sexp (quote_syntax check_stack_param)
                     (sexp (quote_syntax quote) meta))]
              (apply sexp
                (quote_syntax _expect_syntax_exn)
                (sexp (quote_syntax eval)
                  (sexp (quote_syntax quote_syntax) top_form))
                (tail actuals)))
            (quote_syntax here)
            stx)))))
)
