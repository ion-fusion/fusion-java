// Copyright (c) 2012-2014 Amazon.com, Inc.  All rights reserved.

(module struct '/fusion/base'

  '''
Operations for structs.

A _struct_ is an unordered [collection](fusion/collection.html) of values,
keyed by strings.  Since Fusion structs are based on Ion structs, these
collections are multi-maps: the same key can map to multiple values, or even
multiple mappings to the same value. The _elements_ of a struct are its values,
but not the associated field names.

Structs come in two concrete types: immutable and mutable. The predicates
`is_immutable_struct` and `is_mutable_struct` distinguish between them.

## Creating Structs

In standard Fusion, Ion struct syntax denotes immutable values, treating field
names as literals and field values as expressions.  Thus
`{}` denotes an immutable struct of size zero, and `{f:[x]}` denotes an
immutable struct of size 1 holding a list whose only element is the value of
the variable `x`.  The value of a struct
literal is immutable even when some child values are evaluated at run-time,
but elements of such a struct may be mutable.
Quoted forms are also immutable; in `(quote {f:x})` the struct's sole element
is the symbol `'x'`.

The procedure `struct` works like a struct literal, creating an immutable
struct from names and elements:

    (struct "name" "Steve" "age" 29)  =>  {name:"Steve", age:29}

The procedure `mutable_struct` similarly creates mutable structs:

    (mutable_struct "name" "Taylor" "age" 17)  =>  {name:"Taylor", age:17}

Note that the default "ionization strategy" renders all struct types the same,
so the results _look_ similar even though the values have different types.
Eventually the application will be able to control this strategy; these
defaults are designed to allow a Fusion developer to construct data in various
combinations of mutability (*etc.*) and output it as "normal" Ion data.

`struct_zip` and `mutable_struct_zip` provide another way to create (immutable
and mutable) structs. They accept two lists containing the names and elements:

    (struct_zip ["name", "age"] ["Doug", 38])  =>  {age:38, name:"Doug"}


## Modifying Structs

Fusion provides data modification operators that have a functional style, even
when the modification involves mutation. The functional and mutating variants
have the same signature and operate over both immutable and mutable types; in
general they are interchangable when used in a functional style.

Changing the key-value mappings of a struct is performed via `put` and
`put_m`, which guarantee that the result has only a single mapping for
the key:

    (put {a:1, b:9, b:12} "b" 11)  => {a:1, b:11}

The procedures `remove_keys` and `retain_keys` functionally eliminate fields
from a struct without modifying the input; `remove_keys_m` and `retain_keys_m`
modify the input when possible.  `struct_merge` and `struct_merge_m` combine
the fields from two structs.


## Iterating Struct Fields

`struct_iterator` creates a multi-valued [iterator](fusion/iterator.html) over
a struct's key-value pairs.
The procedure `struct_for_each` iterates the name/value pairs within a struct,
but since the input isn't modified one must use side effects.

More general [collection](fusion/collection.html) operations like `any` and
`find` can be applied to structs, in which case the field names are ignored
while the field values are iterated.
  '''

  (require
    "/fusion/collection"
    "/fusion/exception"
    "/fusion/experimental/defines"
    "/fusion/ffi/java"
    "/fusion/iterator"
    "/fusion/list"
    "/fusion/private/struct")

  // Pass-through bindings from /fusion/private/kernel
  (provide is_struct)

  // Pass-through bindings from /fusion/collection
  (provide . any do element elt every find has_key is_collection is_empty none size)

  (defpub_j struct          "com.amazon.fusion.FusionStruct$StructProc")
  (defpub_j mutable_struct  "com.amazon.fusion.FusionStruct$MutableStructProc")

  (defpub_j struct_zip
    "com.amazon.fusion.FusionStruct$StructZipProc")
  (defpub_j mutable_struct_zip
    "com.amazon.fusion.FusionStruct$MutableStructZipProc")

  (defpub_j is_immutable_struct
    "com.amazon.fusion.FusionStruct$IsImmutableStructProc")
  (defpub_j is_mutable_struct
    "com.amazon.fusion.FusionStruct$IsMutableStructProc")

  (defpub_j remove_keys       "com.amazon.fusion.FusionStruct$RemoveKeysProc")
  (defpub_j remove_keys_m     "com.amazon.fusion.FusionStruct$RemoveKeysMProc")
  (defpub_j retain_keys       "com.amazon.fusion.FusionStruct$RetainKeysProc")
  (defpub_j retain_keys_m     "com.amazon.fusion.FusionStruct$RetainKeysMProc")
  (defpub_j struct_merge      "com.amazon.fusion.FusionStruct$StructMergeProc")
  (defpub_j struct_merge_m    "com.amazon.fusion.FusionStruct$StructMergeMProc")




  (defpub put
    (lambda (struct key value)
      '''
Functionally modifies a field of a `struct`, returning a new struct of the same
type. Any existing fields (including repeats) named by the `key` are replaced
by a single field with the `value`.

    (define s {a:1, b:2, b:3})

    (put s "a" 4)    ==> {b:2,b:3,a:4}
    (put s "b" 5)    ==> {b:5,a:1}
    (put s "c" 6)    ==> {b:2,b:3,c:6,a:1}
    s                ==> {b:2,b:3,a:1}
      '''
      (unless (is_struct struct)
        (raise_argument_error "put" "struct" 0 struct key value))
      (unless (is_struct_field_name key)
        (raise_argument_error "put" "field name" 1 struct key value))
      (unsafe_struct_put struct key value)))


  (defpub put_m
    (lambda (struct key value)
      '''
Modifies a field of a `struct`, mutating the `struct` when possible and
returning a struct of the same type. Any existing fields (including repeats)
named by the `key` are replaced by a single field with the `value`.

When given an immutable struct, `put_m` behaves identically to `put`:

    (define s {a:1, b:2, b:3})

    (put_m s "a" 4)    ==> {b:2,b:3,a:4}
    (put_m s "b" 5)    ==> {b:5,a:1}
    (put_m s "c" 6)    ==> {b:2,b:3,c:6,a:1}
    s                  ==> {b:2,b:3,a:1}

When given a mutable struct, the struct is mutated:

    (define s (mutable_struct "a" 1 "b" 2 "b" 3))

    s                ==> {b:2,b:3,a:1}
    (put_m s "a" 4)  ==> {b:2,b:3,a:4}
    (put_m s "b" 5)  ==> {b:5,a:4}
    (put_m s "c" 6)  ==> {b:5,c:6,a:4}
    s                ==> {b:5,c:6,a:4}
      '''
      (unless (is_struct struct)
        (raise_argument_error "put_m" "struct" 0 struct key value))
      (unless (is_struct_field_name key)
        (raise_argument_error "put_m" "field name" 1 struct key value))
      (unsafe_struct_put_m struct key value)))


  (defpub struct_iterator
    (lambda (struct)
      '''
Returns an [iterator][] over the content of `struct`. Calls to `iterator_next`
will return two results representing a single field: the field's name (as a
symbol) and the field's value.

[iterator]: fusion/iterator.html

    (define (show struct)
      (let [(iter (struct_iterator struct))]
        (let loop []
          (when (iterator_has_next iter)
            (let_values [((k v) (iterator_next iter))]
              (displayln k " --> " v)
              (loop))))))
    (show {foo:"bar", hello:"goodbye", yes:false})

This code displays:

    yes --> false
    hello --> goodbye
    foo --> bar
      '''
      (unless (is_struct struct)
        (raise_argument_error "struct_iterator" "struct" 0 struct))
      (unsafe_struct_iterator struct)))


  // Name per Dylan.  Equivalent to SRFI-1 `for_each` but I don't want this to
  // be confused with the `for` syntax from Racket (which I intend to provide).
  (defpub struct_do
    (lambda (proc struct)
      '''
Iterates the fields of `struct` for side-effects, applying `proc` to each
name/value field.  Returns `struct`.  The `proc` must accept two arguments, a
field name symbol and a value; any results from applying the procedure are
ignored.

See also: [`do`](fusion/collection.html#do)
      '''
      (unless (is_procedure proc)
        (raise_argument_error "struct_do" "procedure" 0 proc struct))
      (unless (is_struct struct)
        (raise_argument_error "struct_do" "struct" 1 proc struct))
      (let [(iter (unsafe_struct_iterator struct))]
        (let loop []
          (if (iterator_has_next iter)
            (let_values [((k v) (iterator_next iter))]
              (proc k v)
              (loop))
            struct)))))

  (defpub struct_for_each
    '''
DEPRECATED: renamed to [`struct_do`](fusion/struct.html#struct_do) for
consistency with [`do`](fusion/collection.html#do).

**This binding was deprecated in R11 (November 2013) and will be removed in**
**Q2 2014.**
Comment on [FUSION-233](issue:FUSION-233) if you
cannot migrate in time.
    '''
    struct_do)



  (defpub struct_unzip
    (lambda (struct)
      '''
Deconstructs a `struct` and returns two values: a list of field names (as
symbols) and a list of associated values. This is the inverse of
[`struct_zip`](fusion/struct.html#struct_zip).

    (let_values [((keys vals) (struct_unzip {a:1, b:2}))]
      (struct_zip keys (map - vals)))
    =>
    {b:-2,a:-1}

This procedure returns [multiple results](fusion/procedure.html#results), not
a pair or sequence, so it must be called from a context that expects that, like
a [`let_values`](fusion/procedure.html#let_values) clause with two bound
identifiers.
      '''
      (unless (is_struct struct)
        (raise_argument_error "struct_unzip" "struct" 0 struct))
      (let [(iter (unsafe_struct_iterator struct))]
        // TODO FUSION-226 Allocated these lists with the correct size
        (let loop [(keys (stretchy_list)),
                   (vals (stretchy_list))]
          (if (iterator_has_next iter)
            (let_values [((k v) (iterator_next iter))]
              (loop (add_m keys k) (add_m vals v)))
            (values (apply list keys) (apply list vals)))))))
)
