// Copyright (c) 2012-2013 Amazon.com, Inc.  All rights reserved.

(module check '/fusion/base'

  (use '/fusion/experimental/defines')
  (use '/fusion/ffi/java')
  (use '/fusion/ion')
  (use '/fusion/list')
  (use '/fusion/sexp')
  (use '/fusion/string')
  (use '/fusion/syntax')


  (defpub F (lambda rest false))
  (defpub T (lambda rest true))


  (defpub ion_equals          (java_new "com.amazon.fusion.IonEqualsProc"))

  // NOT PUBLIC YET
  (define raise_check_failure (java_new "com.amazon.fusion.CheckFailureProc"))
  (define thunk_throws_syntax_failure (java_new "com.amazon.fusion.ThunkThrowsProc"))


  (defpub check_equal_annotations
    (lambda (actual expected)
      (check_list_equal (ion_annotations actual) (ion_annotations expected))))

  (defpub check_equal
    (lambda (actual expected descr)
      (cond

// TODO FUSION-88 should support undef
//        ((is_undef expected)
//         (assert (is_undef actual)
//           descr " not equal.\nActual: " actual "\nExpected: " expected))
        ((is_list expected)
         (check_list_equal actual expected))
        ((is_sexp expected)
         (check_sexp_equal actual expected))
        ((is_void expected)
         (assert (is_void actual)
           descr " not equal.\nActual: " actual "\nExpected: " expected))
        (true
         (assert (= actual expected)
           descr " not equal.\nActual: " actual "\nExpected: " expected)))
      (check_equal_annotations actual expected)))

  (defpub check_list_equal
    (lambda (actual expected)
      (assert (is_list actual) "expected list, received: " actual)
      (assert (= (size actual) (size expected))
        "list lengths don't match. Actual: " actual " Expected: " expected)
      (let loop ((i 0))
        (when (< i (size actual))
          (check_equal (. actual i) (. expected i)
            (string_append "list element #" (to_string i)))
          (loop (+ 1 i))))))

  (defpub check_sexp_equal
    (lambda (actual expected)
      (assert (is_sexp actual) "expected sexp, received: " actual)
      (assert (= (size actual) (size expected))
        "sexp sizes don't match. Actual: " actual " Expected: " expected)
      (let loop
           [(pos 0), (a actual), (e expected)]
        (if (is_void e)
          (assert (is_void a)
            "sexp tails don't match at pos " pos ". Actual: " actual " Expected: " expected)
          (begin
            (check_equal (head a) (head e)
              (string_append "sexp element at position " (to_string pos))) // TODO bad descr
            (loop (+ 1 pos) (tail a) (tail e)))))))


  (defpub check_annotations
    (lambda (value expected)
      (let ((anns (ion_annotations value)))
        (check_list_equal anns expected))))


/* This is nowhere near working yet...
  (defpub_syntax define_simple_check
    (lambda (stx)
      (let ((bindings (syntax_get stx 1))
            (body_sexp (syntax_subseq stx 2)))
        (let ((name (syntax_get bindings 0))
              (params (syntax_subseq bindings 1))
              (body_begin (syntax_cons_q begin body_sexp)))

          (quasisyntax
            (define (unsyntax name)
              (lambda (stx)

              )))))))
*/

  (define_syntax do_check  // private
    (lambda (stx)
      '''
(do_check ORIG_STX OP VAL1 VAL2 MSG ...)

Ensures that (OP VAL1 VAL2) is truthy.
      '''
      (let ((orig_stx (syntax_get stx 1))
            (op_stx   (syntax_get stx 2))
            (val1_stx (syntax_get stx 3))
            (val2_stx (syntax_get stx 4))
            (msg_sexp (syntax_subseq stx 5)))
        (quasisyntax
          (let ((op   (unsyntax op_stx))
                (val1 (unsyntax val1_stx))
                (val2 (unsyntax val2_stx)))
            (unless (op val1 val2)
              (unsyntax
                (syntax_append
                  (quasisyntax
                    (raise_check_failure
                      (quote_syntax (unsyntax orig_stx))))
                  msg_sexp
                  (quasisyntax
                    ("\n params:\n  " op
                     "\n  " val1
                     "\n  " val2))))))))))

  (defpub_syntax check
    (lambda (stx)
      '''
(check OP VAL1 VAL2 MSG ...)

Ensures that (OP VAL1 VAL2) is truthy.
      '''
      (when (< (syntax_size stx) 4)
        (wrong_syntax stx "check requires at least three args: (check OP VAL1 VAL2 MSG ...)"))
      (syntax_append
        (quasisyntax (do_check (unsyntax stx)))
        (syntax_subseq stx 1))))


  // The failure message isn't the greatest, its in terms of the inner check
  (defpub_syntax check_true
    (lambda (stx)
      (let ((val1_stx (syntax_get stx 1))
            (msg_sexp (syntax_subseq stx 2)))
        (syntax_append
          (quasisyntax
            (do_check (unsyntax stx) = (unsyntax val1_stx) true))
          msg_sexp))))


  // The failure message isn't the greatest, its in terms of the inner check
  (defpub_syntax check_false
    (lambda (stx)
      (let ((val1_stx (syntax_get stx 1))
            (msg_sexp (syntax_subseq stx 2)))
        (syntax_append
          (quasisyntax
            (do_check (unsyntax stx) = (unsyntax val1_stx) false))
          msg_sexp))))


  // The failure message isn't the greatest, its in terms of the inner check
  (defpub_syntax check_void
    (lambda (stx)
      (let ((val1_stx (syntax_get stx 1))
            (msg_sexp (syntax_subseq stx 2)))
        (syntax_append
          (quasisyntax
            (do_check (unsyntax stx) (lambda (actual expected) (is_void actual))
              (unsyntax val1_stx) false))
          msg_sexp))))


  // TODO this should accept a predicate to check exn type
  (defpub_syntax check_exn
    (lambda (stx)
      // TODO check arity
      (let [(thunk_stx (syntax_get stx 1))]
        (quasisyntax
          // TODO type-check thunk
          (unless (thunk_throws_syntax_failure (unsyntax thunk_stx))
            (raise_check_failure (quote_syntax (unsyntax stx))
              "expected exception"))))))
)
